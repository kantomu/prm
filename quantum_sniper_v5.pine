//@version=5
indicator("TRUE NORTH", shorttitle="TRUE NORTH", overlay=true, max_bars_back=5000)
// ğŸŒŒ Singularity Logic: Navier-Stokes Fluidity, Symplectic Phase
// ğŸ›¡ï¸ Physics-Based Turbulence Detection & Geometric Sync
// âš¡ Optimized: Selection sort O(nÂ²) on small arrays (nâ‰¤15)
// ğŸ¤– ML-inspired: Adaptive correlation-based weights





// ==========================================
// ğŸ“š ä½¿ç”¨ã‚¬ã‚¤ãƒ‰
// ==========================================
// ã€æ¨å¥¨ãƒãƒ£ãƒ¼ãƒˆã€‘15åˆ†è¶³ or 60åˆ†è¶³ï¼ˆæœˆè¶³ãƒ»é€±è¶³ã¯é¿ã‘ã‚‹ï¼‰
// ã€æ¨å¥¨éŠ˜æŸ„ã€‘BTCUSD, USDJPYï¼ˆ24æ™‚é–“ç¨¼åƒï¼‰
// ã€ãƒ¡ãƒ¢ãƒªå¯¾ç­–ã€‘è¤‡æ•°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ä½µç”¨æ™‚ã¯æ³¨æ„
// ã€ãƒ‡ãƒ¼ã‚¿é®®åº¦ã€‘æœˆæ¬¡ãƒ‡ãƒ¼ã‚¿: æ¯æœˆ15æ—¥å‰å¾Œæ›´æ–°ï¼ˆCPI/å¤±æ¥­ç‡/ä¿¡é ¼æ„Ÿï¼‰
// ã€é€±æœ«æ³¨æ„ã€‘é‡‘åˆ©ãƒ»æ ªå¼ãƒ‡ãƒ¼ã‚¿ã¯é‡‘æ›œçµ‚å€¤ã§åœæ­¢ï¼ˆBTC/FXã¯ç¶™ç¶šï¼‰


// ==========================================
// ==========================================
// è¨­å®š (Settings)
// ==========================================

// 1. Language / è¨€èª
string lang_select = input.string("English", "Language", options=["English", "EspaÃ±ol", "æ—¥æœ¬èª"], group="1. GENERAL")

// Language Helper
f_lang(_en, _es, _jp) =>
    lang_select == "EspaÃ±ol" ? _es : lang_select == "æ—¥æœ¬èª" ? _jp : _en

// 2. Mode / ãƒ¢ãƒ¼ãƒ‰
string mode_label = input.string("Auto (Chart)", "Strategy Perspective", options=["Auto (Chart)", "Scalp (1m)", "Tactical (5m)", "Day (15m)", "Day-Swing (1h)", "Swing (4h)", "Position (1D)"], group="1. GENERAL")

// 3. Position / é…ç½®
string pos_string = input.string("Bottom Right â†˜", "Position", options=["Top Right â†—", "Top Center â¬†", "Top Left â†–", "Middle Right ğŸ‘‰", "Middle Center âº", "Middle Left ğŸ‘ˆ", "Bottom Right â†˜", "Bottom Center â¬‡", "Bottom Left â†™"], group="1. GENERAL")

// 4. Size / ã‚µã‚¤ã‚º
int table_scale = input.int(4, "Size (1-7)", minval=1, maxval=7, group="1. GENERAL")

// 5. Signals Only / ã‚·ã‚°ãƒŠãƒ«ã®ã¿è¡¨ç¤º
bool show_signals_only = input.bool(false, "Show Signals Only (Compact Mode)", group="1. GENERAL")

// 6. Watchlist / ã‚¦ã‚©ãƒƒãƒãƒªã‚¹ãƒˆ
string GRP_WATCH = "2. WATCHLIST"
bool en_xau = input.bool(true,  "Gold (XAUUSD)", group=GRP_WATCH)
bool en_btc = input.bool(true,  "Bitcoin (BTCUSD)", group=GRP_WATCH)
bool en_nas = input.bool(true,  "Nasdaq (NAS100)", group=GRP_WATCH)
bool en_uj  = input.bool(true,  "USDJPY", group=GRP_WATCH)
bool en_eu  = input.bool(true,  "EURUSD", group=GRP_WATCH)
bool en_oil = input.bool(true, "Crude Oil (USOIL)", group=GRP_WATCH)
bool en_jpn = input.bool(true, "Nikkei 225 (JP225)", group=GRP_WATCH)
bool en_spx = input.bool(true, "S&P 500 (US500)", group=GRP_WATCH)
// Full Watchlist Options (Default OFF for optimization)
bool en_dax = input.bool(false, "DAX 40 (GER40)", group=GRP_WATCH)
bool en_us02y = input.bool(false, "US 2Y Yield (US02Y)", group=GRP_WATCH)
bool en_gu  = input.bool(false, "GBPUSD", group=GRP_WATCH)
bool en_au  = input.bool(false, "AUDUSD", group=GRP_WATCH)
bool en_ej  = input.bool(false, "EURJPY", group=GRP_WATCH)
bool en_gj  = input.bool(false, "GBPJPY", group=GRP_WATCH)
bool en_aj  = input.bool(false, "AUDJPY", group=GRP_WATCH)


// ==========================================
// ğŸ”’ HIDDEN PARAMETERS (Hardcoded)
// ==========================================

// Map Position String to Pine Constant
string pos_input = position.bottom_right
if pos_string == "Top Right â†—"
    pos_input := position.top_right
else if pos_string == "Top Center â¬†"
    pos_input := position.top_center
else if pos_string == "Top Left â†–"
    pos_input := position.top_left
else if pos_string == "Middle Right ğŸ‘‰"
    pos_input := position.middle_right
else if pos_string == "Middle Center âº"
    pos_input := position.middle_center
else if pos_string == "Middle Left ğŸ‘ˆ"
    pos_input := position.middle_left
else if pos_string == "Bottom Right â†˜"
    pos_input := position.bottom_right
else if pos_string == "Bottom Center â¬‡"
    pos_input := position.bottom_center
else if pos_string == "Bottom Left â†™"
    pos_input := position.bottom_left

// ==========================================
// âš™ï¸ TIME ENGINE: Multi-Timeframe Lookback Logic
// ==========================================
// Determine Mode (Manual or Auto)
string sel_mode = mode_label
if mode_label == "Auto (Chart)"
    int sec = timeframe.in_seconds("")
    if sec <= 60
        sel_mode := "Scalp (1m)"
    else if sec <= 300
        sel_mode := "Tactical (5m)"
    else if sec <= 900
        sel_mode := "Day (15m)"
    else if sec <= 3600
        sel_mode := "Day-Swing (1h)"
    else if sec <= 14400
        sel_mode := "Swing (4h)"
    else
        sel_mode := "Position (1D)"

// Define Logic Tuples: [Resolution, CTX_FX, ANC_FX, CTX_ST, ANC_ST]
// CTX = Short Term Context, ANC = Long Term Anchor
// FX (24h) vs Stock (6.5h) adjusted manually
string calc_res = "15"
int lb_ctx_fx = 96
int lb_anc_fx = 480
int lb_ctx_st = 26
int lb_anc_st = 130

if sel_mode == "Scalp (1m)"
    calc_res := "1", lb_ctx_fx := 60, lb_anc_fx := 240, lb_ctx_st := 60, lb_anc_st := 240
else if sel_mode == "Tactical (5m)"
    calc_res := "5", lb_ctx_fx := 72, lb_anc_fx := 288, lb_ctx_st := 72, lb_anc_st := 78
else if sel_mode == "Day (15m)"
    calc_res := "15", lb_ctx_fx := 96, lb_anc_fx := 480, lb_ctx_st := 26, lb_anc_st := 130
else if sel_mode == "Day-Swing (1h)"
    calc_res := "60", lb_ctx_fx := 48, lb_anc_fx := 240, lb_ctx_st := 14, lb_anc_st := 70
else if sel_mode == "Swing (4h)"
    calc_res := "240", lb_ctx_fx := 30, lb_anc_fx := 120, lb_ctx_st := 10, lb_anc_st := 40
else if sel_mode == "Position (1D)"
    calc_res := "D", lb_ctx_fx := 22, lb_anc_fx := 66, lb_ctx_st := 22, lb_anc_st := 66

// Global Logic Settings (Derived)
string mode_select = (sel_mode == "Swing (4h)" or sel_mode == "Position (1D)" or sel_mode == "Day-Swing (1h)") ? "Swing" : "Intraday"
float sc_threshold = 1.0
int z_smooth_len = 3
// Lookback Assignment for Global Scope
int lookback_bars_fx = lb_ctx_fx
int macro_lb_fx = lb_anc_fx
int lookback_bars_stock = lb_ctx_st
int macro_lb_stock = lb_anc_st

int max_pairs = 13
string layout_mode = "Standard"

// UI Theme (Dark)
string theme_select = "Dark"
bool show_head = true
bool mono_head = false
string sz_head_base = size.large
bool show_risk = true
bool mono_risk = false
string sz_sub_base = size.normal
bool show_ctx = true
bool mono_ctx = false
string sz_ctx_t_base = size.tiny
string sz_ctx_base = size.small
bool show_rec = true
bool mono_rec = false
string sz_rec_t_base = size.tiny
string sz_rec_base = size.normal
bool show_qnt = true
bool mono_qnt = false
string sz_qnt_t_base = size.tiny
string sz_qnt_base = size.small
bool show_rnk = true
bool mono_rnk = false
string sz_rnk_t_base = size.tiny
string sz_rnk_base = size.normal

// Drivers & Sources (All Hardcoded)
string t_us10y   = "TVC:US10Y"
string t_dxy     = "TVC:DXY"
string t_us500   = "FOREXCOM:SPX500"
string t_vix     = "TVC:VIX"
string t_us02y   = "TVC:US02Y"
string t_de10y   = "TVC:DE10Y"
string t_jp10y   = "TVC:JP10Y"
string t_t10yie  = "FRED:T10YIE"
string t_walcl   = "FRED:WALCL"
string t_wtregen = "FRED:WTREGEN"
string t_rrp     = "FRED:RRPONTSYD"
string t_ecb_assets = "FRED:ECBASSETSW"
string t_boj_assets = "FRED:JPNASSETS"

string t_gold   = "FX:XAUUSD"
string t_oil    = "TVC:USOIL"
string t_nas    = "SKILLING:US100"
string t_jp225  = "FX:JPN225"
string t_jpyx   = "TVC:JXY"
string t_btc    = "BITSTAMP:BTCUSD"
string t_eur    = "FX:EURUSD"
string t_gbp    = "FX:GBPUSD"
string t_aud    = "OANDA:AUDUSD"
string t_dax    = "FOREXCOM:GER40"
string t_usdjpy = "FX:USDJPY"
string t_eurjpy = "FX:EURJPY"
string t_gbpjpy = "FX:GBPJPY"
string t_audjpy = "FX:AUDJPY"

// Logic Sensitivity
float z_mid      = 0.5
float z_high     = 2.0
float vix_alert  = 30.0
int corr_len     = 20

// Rate Check
string sym_target_new = "ECONOMICS:USINTR"
string sym_ref_new    = "FRED:DFEDTARU"

// Calculation Helper for scaling
// Logic below (sz_* variables) relies on f_adjust_size which requires these base inputs.
// We reconstruct the size logic here briefly because the function f_adjust_size is defined BELOW in original code.
// BUT we are replacing the block BEFORE the function. The variable assignments (string sz_head = ...)
// happen AFTER the function definition in the original code (lines 160+).
// The replacement block ends at line 287.
// We must be careful not to break the order. 
// "sz_head" etc. utilize "f_adjust_size". "f_adjust_size" is defined at line 160.
// If we replace lines 30-287, we are overwriting f_adjust_size definition!
// We must INCLUDE f_adjust_size in our replacement block or ensure it's preserved.
// Looking at file content: Line 160 is INSIDE the replacement range.
// So we must re-define f_adjust_size inside our replacement content.

// ------------------------------------------
// Size Adjustment Function (Moved/Preserved)
// ------------------------------------------
f_adjust_size(_base_size, _scale) =>
    string result = size.tiny
    if _scale == 1
        result := _base_size == size.large ? size.normal : _base_size == size.normal ? size.small : size.tiny
    else if _scale == 2
        result := _base_size == size.large ? size.normal : _base_size == size.normal ? size.small : size.tiny
    else if _scale == 3
        result := _base_size
    else if _scale == 4
        result := _base_size == size.tiny ? size.small : _base_size == size.small ? size.normal : _base_size
    else if _scale == 5
        result := _base_size == size.tiny ? size.small : _base_size == size.small ? size.normal : size.large
    else if _scale == 6
        result := _base_size == size.tiny ? size.normal : _base_size == size.small ? size.normal : size.large
    else if _scale == 7
        result := _base_size == size.tiny ? size.normal : size.large
    result

// Calculate final sizes based on hardcoded defaults & user scale
string sz_head = f_adjust_size(sz_head_base, table_scale)
string sz_sub = f_adjust_size(sz_sub_base, table_scale)
string sz_ctx_t = f_adjust_size(sz_ctx_t_base, table_scale)
string sz_ctx = f_adjust_size(sz_ctx_base, table_scale)
string sz_rec_t = f_adjust_size(sz_rec_t_base, table_scale)
string sz_rec = f_adjust_size(sz_rec_base, table_scale)
string sz_qnt_t = f_adjust_size(sz_qnt_t_base, table_scale)
string sz_qnt = f_adjust_size(sz_qnt_base, table_scale)
string sz_rnk_t = f_adjust_size(sz_rnk_t_base, table_scale)
string sz_rnk = f_adjust_size(sz_rnk_base, table_scale)
int len_adx = 14
int th_adx = 25


// ğŸ•’ Macro Trend Lookback (Mathematics for Multi-Timeframe)
// Intraday (15m Base) -> Macro Target: 1H Chart / 5 Days
// Swing    (60m Base) -> Macro Target: 4H Chart / 20 Days
// NOTE: We transform "Timeframe" into "Bar Counts" to save request.security calls.


// 1. FX/Crypto (24h Market)
// Intraday: 5 days * 24h = 120h -> 120 * 4 (15m bars) = 480 bars
// Swing: 20 days * 24h = 480h -> 480 / 1 (60m bars) = 480 bars
// (Defined in Time Engine)

// 2. Stocks (6.5h Market)
// Intraday: 5 days * 6.5h = 32.5h -> 32.5 * 4 (15m bars) = 130 bars
// Swing: 20 days * 6.5h = 130h -> 130 / 1 (60m bars) = 130 bars
// (Defined in Time Engine)


// Hybrid Weights
float w_prim = 0.7
float w_macro = 0.3


// ==========================================
// ãƒ‡ãƒ¼ã‚¿å–å¾— & æ§‹é€ ä½“
// ==========================================
type Asset
    string name
    float chg
    float z
    float val
    float abs_chg
    bool is_bull
    float sma200
    float vol_ratio
    float kurt // ğŸŒŒ Quantum Trigger Field
    float reynolds // ğŸŒŠ Fluid Physics: Turbulence
    float velocity // ğŸŒŠ Fluid Physics: Speed
    bool phase_sync // ğŸŒŠ Phase Geometry: Sync Status


// â™¾ï¸ Infinity Logic: Robust Volatility Helper (Median Absolute Deviation)
// Prevents outliers from skewing the volatility constant (Normalizes to Gaussian equivalent)
f_calc_robust_vol(_src, _len) =>
    _med = ta.median(_src, _len)
    _dev = math.abs(_src - _med)
    _mad = ta.median(_dev, _len)
    _mad * 1.4826 // Scale to approximate StdDev


// ğŸŒŒ Quantum Logic: Kurtosis Helper (Fat Tail Detection)
f_calc_kurtosis(_src, _len) =>
    _mean = ta.sma(_src, _len)
    _std = ta.stdev(_src, _len)
    _kurt = 0.0
    if _std != 0
        _sum = 0.0
        for i = 0 to _len - 1
            _sum := _sum + math.pow(_src[i] - _mean, 4)
        _kurt := (_sum / _len) / math.pow(_std, 4)
    _kurt // Normal dist = 3.0


// ğŸŒŠ Singularity Logic: Fluid Physics Engine (Navier-Stokes Proxy)
f_calc_physics(_src, _vol, _len) =>
    // Velocity: Rate of Change of Price (Momentum)
    // ğŸ›¡ï¸ REPLAY FIX: Ensure historical index exists
    _vel = _src - nz(_src[_len], _src)
    // Viscosity: Inverse of Volatility (High Vol = Low Viscosity/Support)
    // We normalize Volatility to prevent division by zero
    _visc = 1.0 / math.max(_vol, 0.001)
    // Reynolds Number (Re) = Inertial Forces / Viscous Forces
    // High Re = Turbulence (Crash/Breakout Risk). Low Re = Laminar (Stable Trend).
    _re = math.abs(_vel) * _vol * 10.0 // Simplified: Momentum * Volatility = Energy Limit
    [_vel, _re]


// ğŸŒŠ Singularity Logic: Phase Engine (Hilbert Transform Proxy)
f_calc_phase(_src, _len) =>
    // Simple 3-pole super smoother or just RSI/Stoch alignment for Phase
    // Here we use Instantaneous Trend sync
    // ğŸ›¡ï¸ REPLAY FIX: Ensure historical index exists
    _mom = _src - nz(_src[3], _src)
    _acc = _mom - nz(_mom[3], _mom)
    // Phase Sync: Momentum and Acceleration are aligned and strong
    bool _sync = (math.sign(_mom) == math.sign(_acc)) and (math.abs(_mom) > ta.stdev(_src, 20))
    _sync


// NOTE: Merged function to save lines and keep security calls efficient
f_calc_hybrid(_sym, _name, _res, _lb_prim, _lb_macro) =>
    // Determine Lookbacks based on Mode & Asset Type
    // (Deprecated internal logic, now passed as args)
   
    // Dynamic Resolution for Swing Mode (Force 240 if Swing, else use default)
    // CRITICAL OPTIMIZATION: To stay under 40 calls, we MUST bundle requests.
    // If we change resolution per call, it counts as new call.
    // We will stick to 'calc_res' for consistency but rely on longer lookbacks for macro.
    // If Swing mode and calc_res is D, then lb_macro 120 is 120 days. That's fine.
    // If Swing mode and calc_res is 240, lb_macro 120 is 120 4H bars (20 days). Perfect.
   
    // Tuple Fetch: [robust_vol, close, close_prim, close_macro, sma, atr_c, atr_avg]
    // ğŸ›¡ï¸ OPTIMIZATION: Calc Physics/Kurtosis OUTSIDE security to prevent Replay Runtime Errors
    [d_robust_vol, c, c_prim, c_macro, sma, atr_c, atr_avg] = request.security(_sym, _res, [f_calc_robust_vol((close-close[1])/close[1]*100, 20), close, close[_lb_prim], close[_lb_macro], ta.sma(close, 200), ta.atr(14), ta.sma(ta.atr(14), 100)], lookahead=barmerge.lookahead_off)


    // Calculate Changes (Safe Division)
    float chg_prim = (c_prim != 0 and not na(c_prim)) ? ((c - c_prim) / c_prim) * 100 : 0
    float chg_macro = (c_macro != 0 and not na(c_macro)) ? ((c - c_macro) / c_macro) * 100 : 0
   
    // Hybrid Change (Blended)
    float _chg = (chg_prim * w_prim) + (chg_macro * w_macro)


    // Z-Score Calculation (Safe Division with Robust Vol)
    float period_vol = d_robust_vol * math.sqrt(_lb_prim)
    float _z = (period_vol != 0 and not na(period_vol)) ? _chg / period_vol : 0
    float _v_r = (atr_avg != 0 and not na(atr_avg)) ? atr_c / atr_avg : 1.0
   
    // ğŸŒŠ Physics & Phase Calculation (Computed in Main Context)
    // ğŸ›¡ï¸ REPLAY FIX: Pass explicit length to avoid variable length errors
    float _vol_norm = d_robust_vol / (c != 0 ? c : 1.0)
   
    // Use NZ() again here just in case, though main context usually safer
    [_vel_val, _re_val] = f_calc_physics(c, _vol_norm, 5)
    bool _p_sync = f_calc_phase(c, 10)
   
    // ğŸŒŒ Kurtosis (computed here)
    // We calculate % change locally to feed kurtosis
    float _pct_chg = (c - nz(c[1], c)) / nz(c[1], c) * 100
    float _kurt_val = f_calc_kurtosis(_pct_chg, 20)


    [Asset.new(_name, _chg, _z, c, math.abs(_chg), c > sma, sma, _v_r, _kurt_val, _re_val, _vel_val, _p_sync)]


// Wrapper functions for compatibility
f_calc_fx(_sym, _name) =>
    f_calc_hybrid(_sym, _name, calc_res, lookback_bars_fx, macro_lb_fx)


f_calc_stock(_sym, _name) =>
    f_calc_hybrid(_sym, _name, calc_res, lookback_bars_stock, macro_lb_stock)


// ğŸ›¡ï¸ Yield-Specific Wrapper
// Reverted to 15m resolution (96 bars = 1 Day) as per user request.
f_calc_yield(_sym, _name) =>
    string _res = calc_res // "15" (Intraday) or "60" (Swing)
    int _lb = mode_select == "Intraday" ? 96 : 24 // 1 Day (96x15m or 24x60m)
    // Yield Macro matches FX Macro (24h/Global)
    f_calc_hybrid(_sym, _name, _res, _lb, macro_lb_fx)


// ã‚¢ã‚»ãƒƒãƒˆåã‚’ã‚·ãƒ³ãƒ—ãƒ«ãªã‚·ãƒ³ãƒœãƒ«åã«çµ±ä¸€ï¼ˆçµµæ–‡å­— + ã‚·ãƒ³ãƒœãƒ«ï¼‰
[d_us10y] = f_calc_yield(t_us10y, "ğŸ‡ºğŸ‡¸US10Y")
[d_dxy]   = f_calc_fx(t_dxy, "ğŸ’µDXY")
[d_us500] = f_calc_stock(t_us500, "ğŸ“ˆSPX")
[d_us02y] = f_calc_yield(t_us02y, "ğŸ‡ºğŸ‡¸US02Y")
[d_vix]   = f_calc_stock(t_vix, "ğŸ˜±VIX")


// âœ… å‹•çš„é–¾å€¤: VIXãƒ‡ãƒ¼ã‚¿å–å¾—å¾Œã«è¨ˆç®—
float dynamic_z_mid = d_vix.val > 25 ? z_mid * 1.6 : (d_vix.val > 20 ? z_mid * 1.2 : z_mid)
float dynamic_z_high = d_vix.val > 25 ? z_high * 1.25 : (d_vix.val > 20 ? z_high * 1.1 : z_high)


// ğŸ§ª Conditional Fetching Helper
f_calc_dummy(_name) => [Asset.new(_name, 0, 0, 0, 0, false, 0, 1, 0, 0, 0, false)]


// ï¿½ Wrapper for Conditional Execution (Fixes tuple assignment error)
//  Wrapper for Conditional Execution (Standard)
f_calc_cond(_need, _sym, _name, _is_fx) =>
    if _need
        if _is_fx
            f_calc_fx(_sym, _name)
        else
            f_calc_stock(_sym, _name)
    else
        f_calc_dummy(_name)


// ğŸ›¡ï¸ Wrapper for Conditional Yields
f_calc_cond_yield(_need, _sym, _name) =>
    if _need
        f_calc_yield(_sym, _name)
    else
        f_calc_dummy(_name)


// ï¿½ğŸ” Dependency Logic (Dynamic Fetching)
bool need_de = en_eu or en_ej or en_dax // Used for EUR pairs & DAX
bool need_gb = en_gu or en_gj // Used for GBP pairs
bool need_au = en_au or en_aj // Used for AUD pairs
bool need_jp = en_uj or en_ej or en_gj or en_aj or en_jpn // Used for JPY pairs & Nikkei


[d_de10y] = f_calc_cond_yield(need_de, t_de10y, "ğŸ‡©ğŸ‡ªDE10Y")
[d_gb10y] = f_calc_dummy("ğŸ‡¬ğŸ‡§GB10Y") // (Removed)
[d_au10y] = f_calc_dummy("ğŸ‡¦ğŸ‡ºAU10Y") // (Removed)
[d_jp10y] = f_calc_cond_yield(need_jp, t_jp10y, "ğŸ‡¯ğŸ‡µJP10Y")
[d_gold]  = f_calc_fx(t_gold, "ğŸ¥‡XAU")
[d_oil]   = f_calc_fx(t_oil, "ğŸ›¢ï¸OIL")
[d_nas]   = f_calc_stock(t_nas, "ğŸ’»NAS")
[d_jp225] = f_calc_stock(t_jp225, "ğŸ‡¯ğŸ‡µNK225")
[d_btc]   = f_calc_fx(t_btc, "â‚¿BTC")
[d_eur]   = f_calc_fx(t_eur, "ğŸ‡ªğŸ‡ºEURUSD")
[d_gbp]   = f_calc_fx(t_gbp, "ğŸ‡¬ğŸ‡§GBPUSD")
[d_aud]   = f_calc_fx(t_aud, "ğŸ‡¦ğŸ‡ºAUDUSD")
[d_uj]    = f_calc_fx(t_usdjpy, "ğŸ‡¯ğŸ‡µUSDJPY")
[d_jpyx]  = f_calc_fx(t_jpyx, "ğŸ’´JXY")


// âœ‚ï¸ ã‚¯ãƒ­ã‚¹å††ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆrequest.securityï¼‰ã¯å‰Šé™¤ã¾ãŸã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
// [d_ej] = f_calc_fx(t_eurjpy, "ğŸ‡ªğŸ‡ºEURJPY") ... ä¸è¦
// [d_gj] = f_calc_fx(t_gbpjpy, "ğŸ‡¬ğŸ‡§GBPJPY") ... ä¸è¦
// [d_aj] = f_calc_fx(t_audjpy, "ğŸ‡¦ğŸ‡ºAUDJPY") ... ä¸è¦


// ğŸ§® åˆæˆãƒ¬ãƒ¼ãƒˆï¼ˆSynthetic Pricesï¼‰ã®è¨ˆç®—
// å–å¾—æ¸ˆã¿ã®ãƒ‰ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã¨ãƒ‰ãƒ«å††ã‚’æ›ã‘åˆã‚ã›ã‚‹ã ã‘ãªã®ã§ã€é€šä¿¡å›æ•°ã¯ã‚¼ãƒ­ã§ã™
float val_ej = d_eur.val * d_uj.val
float val_gj = d_gbp.val * d_uj.val
float val_aj = d_aud.val * d_uj.val


// â€» ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤ºç”¨ã®ãƒ€ãƒŸãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆã‚¨ãƒ©ãƒ¼å›é¿ç”¨ï¼‰
// ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æï¼ˆSMAã‚„Volï¼‰ã¯æŒãŸã›ãšã€ä¾¡æ ¼ã ã‘å…¥ã‚ŒãŸãƒ€ãƒŸãƒ¼ã‚’ä½œã‚Šã¾ã™
Asset d_ej = Asset.new("ğŸ‡ªğŸ‡ºEURJPY", 0, 0, val_ej, 0, true, val_ej, 1.0, 3.0, 0, 0, false)
Asset d_gj = Asset.new("ğŸ‡¬ğŸ‡§GBPJPY", 0, 0, val_gj, 0, true, val_gj, 1.0, 3.0, 0, 0, false)
Asset d_aj = Asset.new("ğŸ‡¦ğŸ‡ºAUDJPY", 0, 0, val_aj, 0, true, val_aj, 1.0, 3.0, 0, 0, false)


[d_dax]   = f_calc_cond(need_de, t_dax, "ğŸ‡©ğŸ‡ªDAX", false)


// ğŸ—‘ï¸ Removed Assets (Dummy Placeholders for safety)
[d_silver] = f_calc_dummy("ğŸ¥ˆXAG")
[d_chf] = f_calc_dummy("ğŸ‡¨ğŸ‡­USDCHF")
[d_cad] = f_calc_dummy("ğŸ‡¨ğŸ‡¦USDCAD")


s_spx = request.security(t_us500, "D", close, lookahead=barmerge.lookahead_off)
s_us10y = request.security(t_us10y, "D", close, lookahead=barmerge.lookahead_off)
// (s_nas removed as unused)
float corr_spx_yield = ta.correlation(s_spx, s_us10y, corr_len)


// -------------------------------------------------------------------------
// ğŸ“‰ Hurst Exponent (Market Health Proxy)
// -------------------------------------------------------------------------
// SPXã®æ—¥è¶³ãƒ‡ãƒ¼ã‚¿(s_spx)ã‚’ä½¿ç”¨ã—ã¦ã€å¸‚å ´ã®é•·æœŸè¨˜æ†¶æ€§ï¼ˆãƒˆãƒ¬ãƒ³ãƒ‰ã®æŒç¶šåŠ›ï¼‰ã‚’æ¸¬å®š
// H > 0.5: ãƒˆãƒ¬ãƒ³ãƒ‰ç›¸å ´ï¼ˆå¥å…¨ï¼‰ / H < 0.5: å¹³å‡å›å¸°ãƒ»ãƒ¬ãƒ³ã‚¸ï¼ˆãƒã‚¤ã‚ºéå¤šï¼‰
int h_len = 50 // è¨ˆç®—æœŸé–“
float h_range = ta.highest(s_spx, h_len) - ta.lowest(s_spx, h_len)
float h_std = ta.stdev(s_spx, h_len)
// ç°¡æ˜“Rescaled Rangeæ³•ã«ã‚ˆã‚‹ãƒãƒ¼ã‚¹ãƒˆæŒ‡æ•°æ¨å®š
float hurst_val = (h_std != 0) ? math.log(h_range / h_std) / math.log(h_len) : 0.5

// ğŸŒŠ Adaptive Thresholds (Hurst)
// HãŒã€Œæ™®æ®µã‚ˆã‚Šé«˜ã„ã‹ä½ã„ã‹ã€ã‚’åˆ¤å®šï¼ˆå›ºå®šå€¤ 0.55 å»ƒæ­¢ï¼‰
float h_sma = ta.sma(hurst_val, 100)
float h_std_dev = ta.stdev(hurst_val, 100)
bool h_high = hurst_val > (h_sma + h_std_dev) // ãƒˆãƒ¬ãƒ³ãƒ‰æ€§ å¼·
bool h_low  = hurst_val < (h_sma - h_std_dev) // ãƒ©ãƒ³ãƒ€ãƒ æ€§ å¼·


// (Macro Monthly Data removed for optimization)


// ==========================================
// ğŸ¦ Global Macro Calculations (Module 1: Global Net Liquidity - Ex China)
// ==========================================
// æ—¢å­˜ã®ç±³å›½ãƒ‡ãƒ¼ã‚¿å–å¾—
float v_t10yie  = request.security(t_t10yie, "D", close, lookahead=barmerge.lookahead_off)
float v_walcl   = request.security(t_walcl, "D", close, lookahead=barmerge.lookahead_off)
float v_wtregen = request.security(t_wtregen, "D", close, lookahead=barmerge.lookahead_off)
float v_rrp     = request.security(t_rrp, "D", close, lookahead=barmerge.lookahead_off)


// ğŸ†• Rate Check Data Acquisition (Removed)


// ğŸ†• Simple Rate Check Data Fetching
// "gaps=barmerge.gaps_off ã‚’ä½¿ã†ã ã‘ã§è‡ªå‹•ã§ç©´åŸ‹ã‚" (æŒ‡å®šãƒ­ã‚¸ãƒƒã‚¯)
val_target_new = request.security(sym_target_new, "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
val_ref_new    = request.security(sym_ref_new,    "D", close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
float val_ref_3m = request.security(sym_ref_new, "D", close[66], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on) // Approx 3 months


// æ–°è¦: ä¸–ç•Œã®ä¸­å¤®éŠ€è¡Œãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆä¸­å›½ã‚’é™¤å¤–ï¼‰+ ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—å–å¾—ã§ãŠé®®åº¦ç®¡ç†
[v_ecb, t_ecb] = request.security(t_ecb_assets, "D", [close, time], lookahead=barmerge.lookahead_off)
[v_boj, t_boj] = request.security(t_boj_assets, "D", [close, time], lookahead=barmerge.lookahead_off)

// ğŸ“‰ Data Freshness Decay Function
// ãƒ‡ãƒ¼ã‚¿ãŒå¤ã„ã»ã©ã€Œ1.0 -> 0.0ã€ã«æ¸›è¡°ã™ã‚‹ä¿‚æ•°ã‚’è¿”ã™
f_calc_freshness(_t_data) =>
    int _days_old = (timenow - _t_data) / 86400000 // ms to days
    // 7æ—¥ä»¥å†…ãªã‚‰1.0 (æ–°é®®)ã€30æ—¥çµŒéã§0ã«æ¸›è¡°
    float _decay = _days_old < 7 ? 1.0 : (_days_old > 30 ? 0.0 : 1.0 - ((_days_old - 7.0) / 23.0))
    math.max(0.0, _decay)

float fresh_ecb = f_calc_freshness(t_ecb)
float fresh_boj = f_calc_freshness(t_boj)






// ğŸŒŒ Module 5: Market Coherence Map (Systemic Risk Radar)
// Calculate pair-wise correlations between 4 Pillars: SPX, US10Y(Yield), DXY, Gold
// This is a lightweight proxy for PCA (Principal Component Analysis)
// High Coherence (>0.7) = Systemic Event (Everything moves together -> Cash is King)
// Low Coherence (<0.3) = Stock Pickers Market
float corr_s_y = math.abs(ta.correlation(d_us500.z, d_us10y.z, 20))
float corr_s_d = math.abs(ta.correlation(d_us500.z, d_dxy.z, 20))
float corr_s_g = math.abs(ta.correlation(d_us500.z, d_gold.z, 20))
float corr_y_d = math.abs(ta.correlation(d_us10y.z, d_dxy.z, 20))
float coherence_val = (corr_s_y + corr_s_d + corr_s_g + corr_y_d) / 4.0


// Coherence Regimes
bool is_sys_risk = coherence_val > 0.70 // 70% Alert
bool is_crash_risk = coherence_val > 0.90 // 90% Cash Out
bool is_coherent_trend = coherence_val > 0.4 and coherence_val <= 0.7


// ğŸŒŒ Module 4: Hybrid Entropy Weighting (The Brain)
// Compare Volatility (Information Flow) of Rates vs Liquidity
float vol_rate = f_calc_robust_vol(d_us10y.val, 20) / ta.sma(d_us10y.val, 20) // Normalized Vol
float vol_liq  = f_calc_robust_vol(d_us500.val, 20) / ta.sma(d_us500.val, 20)
float entropy_bias = 0.0
// If Rate Vol is 2x Liquidity Vol -> Rate Driven
if vol_rate > (vol_liq * 2.0)
    entropy_bias := 1.0 // Shift to Rates
else if vol_liq > (vol_rate * 2.0)
    entropy_bias := -1.0 // Shift to Liquidity


// 1. ç±³å›½ãƒãƒƒãƒˆæµå‹•æ€§ï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
float raw_us_liq = v_walcl - (v_wtregen * 1000) - (v_rrp * 1000)


// 2. å„å›½ã®æ­£è¦åŒ–ï¼ˆZã‚¹ã‚³ã‚¢åŒ–ï¼‰é–¢æ•°
f_calc_z(_src, _len) =>
    float _chg = _src - _src[5] // 1é€±é–“ï¼ˆ5å–¶æ¥­æ—¥ï¼‰ã®å¤‰åŒ–é‡
    float _std = ta.stdev(_chg, _len)
    _std != 0 ? _chg / _std : 0


// 3. å„è¦ç´ ã®Zã‚¹ã‚³ã‚¢ç®—å‡ºï¼ˆæœŸé–“: 50æ—¥ï¼‰
float z_us  = f_calc_z(raw_us_liq, 50)
float z_ecb = f_calc_z(v_ecb, 50)
float z_boj = f_calc_z(v_boj, 50)


// 4. ã‚°ãƒ­ãƒ¼ãƒãƒ«æµå‹•æ€§ã‚¹ã‚³ã‚¢ã®çµ±åˆ (Global_Liq_Score)
// ğŸš€ ãƒ‡ãƒ¼ã‚¿é®®åº¦ã«ã‚ˆã‚‹å‹•çš„åŠ é‡å¹³å‡ (Freshness Weighted Average)
// ECB/BoJã®ãƒ‡ãƒ¼ã‚¿ãŒå¤ã„å ´åˆã€ãã®å½±éŸ¿åº¦ã‚’ä¸‹ã’ã€ç›¸å¯¾çš„ã«USãƒ‡ãƒ¼ã‚¿(å¸¸ã«æ–°é®®)ã®æ¯”é‡ã‚’é«˜ã‚ã‚‹
float w_total = 0.50 + (0.25 * fresh_ecb) + (0.25 * fresh_boj)
float Global_Liq_Score = ((z_us * 0.50) + (z_ecb * 0.25 * fresh_ecb) + (z_boj * 0.25 * fresh_boj)) / w_total


// æ—¢å­˜å¤‰æ•°ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°
float liq_z = Global_Liq_Score


// å®Ÿè³ªé‡‘åˆ©ã®è¨ˆç®—ï¼ˆæ—¢å­˜ç¶­æŒï¼‰
float val_real_yield = d_us10y.val - v_t10yie
float ry_z_raw = ta.stdev(val_real_yield - val_real_yield[5], 50)
float ry_z = ry_z_raw != 0 ? (val_real_yield - val_real_yield[5]) / ry_z_raw : 0


// ==========================================
// ğŸ§  FRB Cycle & Adaptive Weights (Module 2: Cycle & kNN-like)
// ==========================================


// 1. ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆFFãƒ¬ãƒ¼ãƒˆ & SPXã®æ—¥è¶³é«˜å®‰: ADXè¨ˆç®—ç”¨ï¼‰


// -------------------------------------------------------------------------
// ğŸ¦ FRB Rate Logic Removed
// -------------------------------------------------------------------------


// SPXãƒ‡ãƒ¼ã‚¿ã®å–å¾—ï¼ˆã“ã“ã¯å¤‰æ›´ãªã—ï¼‰
[spx_h, spx_l, spx_c] = request.security("FOREXCOM:SPX500", "D", [high, low, close], lookahead=barmerge.lookahead_off)
// d_us02y.val ã¯ç¾åœ¨ã®2å¹´å‚µåˆ©å›ã‚Š
// ğŸ”„ Module 2: FRB Cycle Integration (Restored)
// Using logic from Simple Rate Check (spread_new inferred here for global scope)
float _spread_global = d_us02y.val - val_ref_new
bool is_hiking_cycle  = _spread_global > 0.25  // Hike Expectation
bool is_cutting_cycle = _spread_global < -0.25 // Cut Expectation
bool is_neutral_cycle = not is_hiking_cycle and not is_cutting_cycle


// 3. å¸‚å ´ç’°å¢ƒã®æ¸¬å®š (SPXã«åŸºã¥ãADXã¨ATR)
// æ—¢å­˜ã®é–¢æ•°ãŒãªã„ãŸã‚ã€ã“ã“ã§ç°¡æ˜“è¨ˆç®—ï¼ˆé–¢æ•°åŒ–ã‚‚å¯èƒ½ã ãŒã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å±•é–‹ã§è»½é‡åŒ–ï¼‰
// True Range
float _tr = math.max(math.max(spx_h - spx_l, math.abs(spx_h - spx_c[1])), math.abs(spx_l - spx_c[1]))
// ATR (Smooth)
float _atr = ta.rma(_tr, 14)
float _atr_avg = ta.sma(_atr, 100)
bool is_high_vol = _atr > (_atr_avg * 1.2) // å¹³å‡ã‚ˆã‚Š20%ä»¥ä¸Šãƒœãƒ©ãŒé«˜ã„


// ADX (Directional Movement)
float _up = spx_h - spx_h[1]
float _dn = spx_l[1] - spx_l
float _plus = (_up > _dn and _up > 0) ? _up : 0
float _minus = (_dn > _up and _dn > 0) ? _dn : 0
float _s_plus = ta.rma(_plus, len_adx)
float _s_minus = ta.rma(_minus, len_adx)
float _s_tr = ta.rma(_tr, len_adx)
float _di_plus = _s_tr != 0 ? 100 * _s_plus / _s_tr : 0
float _di_minus = _s_tr != 0 ? 100 * _s_minus / _s_tr : 0
float _dx = (_di_plus + _di_minus > 0) ? 100 * math.abs(_di_plus - _di_minus) / (_di_plus + _di_minus) : 0
float _adx = ta.rma(_dx, len_adx)
bool is_strong_trend = _adx > th_adx


// 4. é©å¿œå‹ã‚¦ã‚§ã‚¤ãƒˆ (Adaptive Weights) - ğŸš€ Hybrid Entropy Upgrade
// Base Rule (Module 2)
float w_liq_base  = (is_high_vol or is_strong_trend) ? 0.8 : 0.3
float w_rate_base = (is_high_vol or is_strong_trend) ? 0.2 : 0.7


// Hybrid Mixing: Base (70%) + Entropy (30% Override)
// If entropy_bias is extreme, we shift weights dynamically
w_liq  = w_liq_base
w_rate = w_rate_base


if entropy_bias > 0.5 // Rates are moving wildly
    w_rate := math.max(w_rate, 0.8) // Force High Rate Weight
    w_liq  := 1.0 - w_rate
else if entropy_bias < -0.5 // Liquidity/Equity is wild
    w_liq  := math.max(w_liq, 0.8)
    w_rate := 1.0 - w_liq


// ã‚µã‚¤ã‚¯ãƒ«ã®çŠ¶æ…‹ã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç”¨ã«ä¿å­˜
// ğŸ”„ Cycle Message Restored
string cycle_msg = is_hiking_cycle ? "ğŸ¦… Hike Cycle" : is_cutting_cycle ? "ğŸ•Šï¸ Cut Cycle" : "âš–ï¸ Neutral"




bool core_data_ok = not na(d_vix.val) and not na(d_us500.val) and not na(d_dxy.val) and not na(d_us10y.val)
bool is_weekend = (dayofweek == dayofweek.saturday or dayofweek == dayofweek.sunday)
bool data_alert = not core_data_ok and not is_weekend


var list = array.new<Asset>(0)
array.clear(list)
array.push(list, d_us10y), array.push(list, d_dxy), array.push(list, d_vix)
array.push(list, d_gold), array.push(list, d_oil), array.push(list, d_btc)
array.push(list, d_us500), array.push(list, d_nas), array.push(list, d_jp225)
array.push(list, d_us02y), array.push(list, d_de10y)
// (GB10Y, AU10Y removed from candidates)
array.push(list, d_jp10y), array.push(list, d_jpyx)
// ğŸš€ ASSET LIST GENERATION (Stabilized)
// Calculate only on confirmed bars (Close) to prevent flickering
if barstate.isconfirmed
    array.clear(list)
    array.push(list, d_us10y), array.push(list, d_dxy), array.push(list, d_vix)
    array.push(list, d_gold), array.push(list, d_oil), array.push(list, d_btc)
    array.push(list, d_us500), array.push(list, d_nas), array.push(list, d_jp225)
    array.push(list, d_us02y), array.push(list, d_de10y)
    // (GB10Y, AU10Y removed from candidates)
    array.push(list, d_jp10y), array.push(list, d_jpyx)
    array.push(list, d_dax)

    int n = array.size(list)
    if n > 1
        for i = 0 to n - 2
            int max_idx = i
            for j = i + 1 to n - 1
                if array.get(list, j).abs_chg > array.get(list, max_idx).abs_chg
                    max_idx := j
            if max_idx != i
                Asset temp = array.get(list, i)
                array.set(list, i, array.get(list, max_idx))
                array.set(list, max_idx, temp)
// ğŸŸ¢ ã€ä¿®æ­£1ã€‘ ã“ã“ã«ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’æŒ¿å…¥ï¼ˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã®ç›´å‰ï¼‰
// -------------------------------------------------------------------------
// ğŸš¨ ã‚¨ãƒ©ãƒ¼ä¿®æ­£: ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã«å¿…è¦ãªå¤‰æ•°ã‚’ã“ã“ã§å…ˆã«å®šç¾©
// -------------------------------------------------------------------------
// âœ… ç–‘ä¼¼ML: ç›¸é–¢ãƒ™ãƒ¼ã‚¹ã®å‹•çš„ã‚¦ã‚§ã‚¤ãƒˆ
float corr_yield_dxy = ta.ema(ta.correlation(d_us10y.z, d_dxy.z, 50), 10)
bool strong_correlation = math.abs(corr_yield_dxy) > 0.6


// ä»¥å‰ã®ãƒ­ã‚¸ãƒƒã‚¯ã§ä½¿ã‚ã‚Œã¦ã„ãŸ yield_weight ã‚’ã€Module 2ã® w_rate ã§ä»£ç”¨å®šç¾©
float yield_weight = w_rate


// ãƒ•ãƒ©ã‚°å®šç¾© (ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã§ä½¿ã†ãŸã‚ä¸Šã«ç§»å‹•)
bool rising_unemp = false
bool falling_conf = false
bool high_inflation = false  // ğŸ‘ˆ ã“ã®è¡Œã‚’è¿½åŠ ï¼


// ãƒ‘ãƒ‹ãƒƒã‚¯åˆ¤å®š (panic_mode) ã‚‚ã“ã“ã§å®šç¾©
// ğŸ”„ Module 3: VIX Percentile & Dynamic Risk
float vix_rank = ta.percentrank(d_vix.val, 252 * 2) // Past 2 Years Percentile
bool is_panic_rank = vix_rank > 95
bool panic_mode = d_vix.val > vix_alert or d_vix.z > dynamic_z_high or is_panic_rank
bool jpy_crash  = d_jpyx.z < -dynamic_z_high


// ğŸ”„ Module 3: Correlation Flipping (Physics)
// æ ªã¨é‡‘åˆ©ã®ç›¸é–¢ã«ã‚ˆã‚‹ãƒ¬ã‚¸ãƒ¼ãƒ åˆ¤å®š
bool yield_is_bad = corr_spx_yield < -0.3 // é‡‘åˆ©ä¸Šæ˜‡ = æ ªå®‰ (ã‚¤ãƒ³ãƒ•ãƒ¬æ‡¸å¿µ)
bool yield_is_good = corr_spx_yield > 0.3 // é‡‘åˆ©ä¸Šæ˜‡ = æ ªé«˜ (æ™¯æ°—å›å¾©)


// ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ»æ–¹å‘æ€§ãƒ•ãƒ©ã‚°
bool y_up = d_us10y.z > dynamic_z_mid, y_dn = d_us10y.z < -dynamic_z_mid
bool d_up = d_dxy.z > dynamic_z_mid, d_dn = d_dxy.z < -dynamic_z_mid
bool s_up = d_us500.z > dynamic_z_mid, s_dn = d_us500.z < -dynamic_z_mid
bool g_up = d_gold.z > dynamic_z_mid, g_dn = d_gold.z < -dynamic_z_mid
bool b_up = d_btc.z > dynamic_z_mid, b_dn = d_btc.z < -dynamic_z_mid
bool o_up = d_oil.z > dynamic_z_mid
bool j_up = d_jpyx.z > dynamic_z_mid
bool j_dn = d_jpyx.z < -dynamic_z_mid
// -------------------------------------------------------------------------
// ==========================================
// ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
// ==========================================
float f_risk = 0.0
f_risk := f_risk + (d_us500.z > 0.3 ? 1 : d_us500.z < -0.3 ? -1 : 0)
f_risk := f_risk + (d_vix.z < -0.5 ? 1 : d_vix.z > 0.5 ? -1 : 0)
f_risk := f_risk + (d_btc.z > 0.5 ? 0.5 : d_btc.z < -0.5 ? -0.5 : 0)
f_risk := f_risk + (d_gold.z < -0.5 ? 0.5 : d_gold.z > 0.5 ? -0.5 : 0)
// ğŸ”„ Module 3: Fractal Confluence (Filtering) (Infinity Logic)
// HurstæŒ‡æ•°ã«ã‚ˆã‚‹ã‚¹ã‚³ã‚¢èª¿æ•´ï¼ˆé©å¿œå‹é–¾å€¤ã«å¤‰æ›´ï¼‰
float fractal_mult = h_high ? 1.2 : (h_low ? 0.8 : 1.0)

// ğŸŒŠ Adaptive Thresholds (Reynolds - Turbulence)
// ãƒ¬ã‚¤ãƒãƒ«ã‚ºæ•°(ä¹±æµ)ã®é©å¿œå‹é–¾å€¤
float re_src = d_us500.reynolds // ä»£è¡¨ã¨ã—ã¦SPXã®ä¹±æµåº¦ã‚’ä½¿ç”¨
float re_sma = ta.sma(re_src, 50)
float re_std = ta.stdev(re_src, 50)
bool is_turbulent = re_src > (re_sma + re_std) // å¹³å¸¸æ™‚ã‚ˆã‚Šä¹±æµåº¦ãŒçªå‡ºã—ã¦ã„ã‚‹

// âš¡ Fast Veto Trigger (Short-term Volatility)
// US02Y(æ”¿ç­–é‡‘åˆ©æ„Ÿå¿œåº¦)ãŒæ—¥ä¸­ã«2Ïƒä»¥ä¸Šå‹•ã„ãŸã‚‰ã€ãƒã‚¯ãƒ­åˆ¤æ–­ã‚’ä¸€æ™‚åœæ­¢ï¼ˆè¦äººç™ºè¨€ç­‰ã®ãƒã‚¤ã‚ºå›é¿ï¼‰
float us02y_change = math.abs(d_us02y.val - d_us02y.val[1])
float us02y_vol = ta.stdev(d_us02y.val - d_us02y.val[1], 20)
bool veto_fast = us02y_change > (us02y_vol * 3.0) // 3ã‚·ã‚°ãƒç´šã®çªç™ºå¤‰å‹•


// ã‚¹ã‚³ã‚¢ãƒ«ãƒ¼ãƒ—å†…ã§ã®é©ç”¨
if rising_unemp
    f_risk := f_risk - 1.5


// ğŸŒ Macro Regimes (New Engine)
// Goldilocks: Growth + Liquidity + Stable Yields (Ideal for Stocks)
bool reg_goldilocks = (d_us500.is_bull or d_us500.z > 0) and liq_z > -0.5 and ry_z < 1.0 and d_vix.val < 20
// Reflation: Growth + Yields Up + Commodities Up (Inflationary Growth)
bool reg_reflation = d_us500.z > 0 and d_us10y.z > 0.5 and d_oil.z > 0.5
// Stagflation: Yields Up + Commodities Up + Stocks Down (Bad Inflation)
bool reg_stagflation = d_us10y.z > 0.5 and d_oil.z > 0.5 and d_us500.z < -0.5
// Liquidity Crisis: Net Liq Crashing + VIX Spiking (Cash is King)
bool reg_liq_crisis = liq_z < -1.5 and d_vix.val > 25
// Deflation: Yields Down + Oil Down + Stocks Down
// Deflation: Yields Down + Oil Down + Stocks Down
bool reg_deflation = d_us10y.z < -1.0 and d_oil.z < -1.0 and d_us500.z < -0.5


// ==========================================
// ğŸŒŠ Driver Derivatives & Adaptive Scoring (Module 3: Integration)
// ==========================================


// 1. ã‚¤ãƒ¼ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ–ãƒ»å®Ÿè³ªé‡‘åˆ©ãƒ¬ã‚¸ãƒ¼ãƒ  (æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã®æ•´ç†)
float yield_curve = d_us10y.val - d_us02y.val
bool curve_inverted = yield_curve < -0.2
bool curve_steep    = yield_curve > 0.8
bool real_rate_clamped = ry_z > 2.0 // å®Ÿè³ªé‡‘åˆ©ãŒé«˜ã™ãã¦æ ª/GoldãŒæ­»ã¬ãƒ¬ãƒ™ãƒ«


// 2. é©å¿œå‹ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ãƒ»ã‚¨ãƒ³ã‚¸ãƒ³
// ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«2ã§ç®—å‡ºã—ãŸ w_rate (é‡‘åˆ©é‡è¦–åº¦) ã¨ w_liq (æµå‹•æ€§é‡è¦–åº¦) ã‚’é©ç”¨


// ğŸ’µ USD Score:
// åˆ©ä¸Šã’ã‚µã‚¤ã‚¯ãƒ«(Hiking)ãªã‚‰é‡‘åˆ©æ„Ÿå¿œåº¦ã‚’ä¸Šã’ã€åˆ©ä¸‹ã’ã‚µã‚¤ã‚¯ãƒ«ãªã‚‰çµŒæ¸ˆæŒ‡æ¨™(DXYè‡ªä½“)ã‚’é‡è¦–
float weight_us_yield = is_hiking_cycle ? 1.2 : 0.8
float s_usd = d_dxy.z + (d_us10y.z * w_rate * weight_us_yield)


// ğŸ’´ JPY Score:
// å¾“æ¥: å˜ç´”ãªé‡‘åˆ©å·®
// æ–°ç‰ˆ: ãƒªã‚¹ã‚¯ã‚ªãƒ•æ™‚(VIXé«˜)ã®å††è²·ã„åœ§åŠ› + æ—¥éŠ€æµå‹•æ€§(z_boj)ã®ã‚µãƒãƒ¼ãƒˆã‚’åŠ å‘³
// w_liqãŒé«˜ã„(è’ã‚Œç›¸å ´)æ™‚ã¯ã€é‡‘åˆ©å·®ã‚ˆã‚Šã‚‚ã€Œææ€–ã«ã‚ˆã‚‹å††è²·ã„ã€ãŒå„ªå…ˆã•ã‚Œã‚‹è¨­è¨ˆ
float risk_premium_jpy = (d_vix.z > 0.5 ? 0.8 : 0) + (panic_mode ? 1.5 : 0)
float s_jpy = d_jpyx.z + risk_premium_jpy - (d_us10y.z * w_rate) + (z_boj * 0.3)


// ğŸ’¶ EUR Score:
// æ¬§å·æµå‹•æ€§(z_ecb)ã¨ãƒ‰ã‚¤ãƒ„é‡‘åˆ©ã‚’åŠ å‘³
float s_eur = d_eur.z + (d_de10y.z * w_rate * 0.8) + (z_ecb * 0.2)


// ğŸ’· GBP Score (Enhanced Proxy):
// SPX(ãƒªã‚¹ã‚¯ã‚»ãƒ³ãƒãƒ¡ãƒ³ãƒˆ)ã¨ã®é€£å‹•æ€§ãŒé«˜ã„é€šè²¨
float s_gbp = d_gbp.z + (d_us500.z * 0.4) + (s_eur * 0.4) + (f_risk > 0 ? 0.3 : 0)


// ğŸ‡¦ğŸ‡º AUD Score (Resource & China Proxy):
// å¾“æ¥ã®Gold/Oilã«åŠ ãˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«1ã§è¨ˆç®—å¯èƒ½ãªã€Œä¸­å›½/ã‚°ãƒ­ãƒ¼ãƒãƒ«æµå‹•æ€§ã€ã‚’åŠ å‘³ã™ã‚‹ãŒ
// ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ãƒ™ãƒ¼ã‚¹ã®Global_Liq_Score(liq_z)ã‚’è³‡æºéœ€è¦ã¨ã—ã¦åŠ ç®—
float s_aud = d_aud.z + (d_gold.z * 0.3) + (d_oil.z * 0.3) + (liq_z * 0.3)


// ğŸ¥‡ GOLD Score (Safe Haven vs Real Rates):
// æœ€ã‚‚åŠ‡çš„ã«å¤‰ã‚ã‚‹éƒ¨åˆ†ã€‚
// ã€Œé‡‘åˆ©ãŒä¸ŠãŒã£ã¦ã‚‚ã€æµå‹•æ€§ãŒã‚¸ãƒ£ãƒ–ã‚¸ãƒ£ãƒ–ãªã‚‰Goldã¯ä¸‹ãŒã‚‰ãªã„ã€ç¾è±¡ã‚’å†ç¾ã€‚
// w_rateãŒé«˜ã„(å¹³æ™‚) â†’ å®Ÿè³ªé‡‘åˆ©(ry_z)ã«é€†ç›¸é–¢ã—ã¦å‹•ã
// w_liqãŒé«˜ã„(æ··ä¹±æ™‚) â†’ æµå‹•æ€§(liq_z)ã¨ææ€–(VIX)ã«åå¿œã—ã¦ä¸ŠãŒã‚‹
float s_xau = d_gold.z + (liq_z * w_liq * 1.5) - (ry_z * w_rate * 1.5) + (d_vix.z > 1.0 ? 1.0 : 0)


// â‚¿ BITCOIN Score (Pure Liquidity Play):
// ãƒ“ãƒƒãƒˆã‚³ã‚¤ãƒ³ã¯ã€Œå®Ÿè³ªé‡‘åˆ©ã€ã¨ã€Œæµå‹•æ€§ã€ã®ãƒ¬ãƒãƒ¬ãƒƒã‚¸ãƒ—ãƒ¬ã‚¤
// w_liq(æµå‹•æ€§ã‚¦ã‚§ã‚¤ãƒˆ)ã‚’2å€é©ç”¨ã€‚é‡‘åˆ©ä¸Šæ˜‡(Hiking)ã«ã¯å¼±ã„ã€‚
float s_btc = d_btc.z + (liq_z * w_liq * 2.0) - (ry_z * w_rate * 1.2) + (d_nas.z * 0.5)


// (CHF, CAD removed)


// ğŸ“Š Asset Scenarios (A/B Logic)


// USDJPY: Scenario A (Yield Diff) vs B (Risk Off)
float sc_uj_a = (d_us10y.z - d_jp10y.z) * (reg_goldilocks ? 1.2 : 1.0) // Yield Drive
float sc_uj_b = (reg_liq_crisis or d_vix.z > 2.0) ? -4.0 : 0 // Panic Repatriation
float sc_usdjpy = en_uj ? (s_usd - s_jpy) + sc_uj_a + sc_uj_b : 0


// EURUSD: Scenario A (Policy Div) vs B (Global Growth)
float sc_eu_a = (d_de10y.z - d_us10y.z) * yield_weight
float sc_eu_b = reg_goldilocks ? 0.5 : (reg_liq_crisis ? -0.5 : 0) // Growth seeks Euro
float sc_eurusd = en_eu ? (s_eur - s_usd) + sc_eu_a + sc_eu_b : 0


// GBPUSD: Scenario A (Growth Prem) vs B (Fiscal Risk)
// Enhanced: Uses SPX as growth proxy since GB10Y is gone
float sc_gu_a = (d_us500.z > 0.5 and d_us500.is_bull) ? 1.0 : 0
float sc_gu_b = (d_us500.z < -1.0) ? -1.0 : 0 // Risk Off hits Cable hard
float sc_gbpusd = en_gu ? (s_gbp - s_usd) + sc_gu_a + sc_gu_b : 0


// AUDUSD: Scenario A (Commodities) vs B (China/Asia)
// Enhanced: Link to Gold & Oil explicitly
float sc_au_a = (d_oil.z * 0.5) + (d_gold.z * 0.5) // Commodity Supercycle
float sc_au_b = (d_jp225.z < -1.0) ? -0.8 : 0 // Asia weakness
float sc_audusd = en_au ? (s_aud - s_usd) + sc_au_a + sc_au_b : 0


// (USDCHF scenario removed)
float sc_usdchf = 0


// (USDCAD scenario removed)
float sc_usdcad = 0


// CROSS YEN: Scenario A (Carry) vs B (Bubble Burst)
// Carry Trade thrives in Goldilocks/Reflation, dies in Crisis/Vike Spike
float carry_env = (reg_goldilocks or reg_reflation) ? 1.0 : 0
float burst_env = (reg_liq_crisis or d_vix.z > 2.0 or d_jpyx.z > 2.0) ? -4.0 : 0
float sc_eurjpy = en_ej ? (s_eur - s_jpy) + carry_env + burst_env : 0
float sc_gbpjpy = en_gj ? (s_gbp - s_jpy) + carry_env + burst_env : 0
float sc_audjpy = en_aj ? (s_aud - s_jpy) + carry_env + burst_env : 0


// COMMODITIES: Gold & Oil
// Gold: Hates Real Rates, Loves Liquidity & Fear
float sc_xau_a = (liq_z * 0.8) + (ry_z * -1.2) // Primary Drivers
float sc_xau_b = (d_vix.z > 1.5) ? 1.0 : 0 // Safe Haven
float sc_xauusd = en_xau ? d_gold.z + sc_xau_a + sc_xau_b : 0


// Oil: Growth (SPX) vs Dollar (DXY)
float sc_oil_a = (d_us500.z > 0.5) ? 0.8 : (d_us500.z < -1.0) ? -1.0 : 0 // Demand
float sc_oil_b = (d_dxy.z > 1.0) ? -0.5 : 0 // Dollar Headwind
float sc_oil = en_oil ? d_oil.z + sc_oil_a + sc_oil_b : 0


// CRYPTO & BONDS
// BTC: Pure Liquidity Sponge
float sc_btc_a = (liq_z * 2.5) + (ry_z * -1.0) // Liquidity/Rates
float sc_btc_b = (d_nas.z > 0.5) ? 0.8 : 0 // Tech Beta
float sc_btc = en_btc ? d_btc.z + sc_btc_a + sc_btc_b : 0


// INDICES: NAS100 (Liquidity Sensitive) & SPX500 (Broad Market)
// NAS: Heavily impacted by Real Rates (Valuation) and Net Liquidity
float sc_nas_a = (liq_z * 1.5) + (ry_z * -1.2)
float sc_nas_b = (d_us02y.z > 1.0) ? -1.0 : (d_us02y.z < -0.5) ? 0.5 : 0 // Rate Cut hopes
float sc_nas = en_nas ? d_nas.z + sc_nas_a + sc_nas_b : 0


// SPX: Economic Health vs Fed tightening
float sc_spx_a = (d_us500.is_bull and not curve_inverted) ? 0.6 : 0 // Healthy Growth
float sc_spx_b = (d_vix.z < -0.5) ? 0.4 : (d_vix.z > 1.5) ? -1.2 : 0 // Volatility Penalty
float sc_spx = en_spx ? d_us500.z + sc_spx_a + sc_spx_b : 0


// JP225: Global Beta + Currency Impact
float sc_jp225 = en_jpn ? d_jp225.z + (d_uj.z * 0.4) + (sc_spx > 0 ? 0.4 : 0) : 0


// DAX: Euro Weakness (Export) + Global Beta
float sc_dax_a = (s_eur < -0.5) ? 0.5 : 0 // Weak Euro helps German exports
float sc_dax_b = (d_us500.z * 0.5) // Correlation to US Stocks
float sc_dax = en_dax ? d_dax.z + sc_dax_a + sc_dax_b : 0


// US02Y: Fed Policy Proxy (Tradeable)
float sc_us02y = en_us02y ? d_us02y.z + (high_inflation ? 1.0 : 0) : 0


// (Duplicate Commodities/Crypto block removed)


float ema_gold = ta.ema(d_gold.z, z_smooth_len)
// (Silver, CHF, CAD EMAs removed)
float ema_uj = ta.ema(d_uj.z, z_smooth_len)
float ema_eur = ta.ema(d_eur.z, z_smooth_len)
float ema_gbp = ta.ema(d_gbp.z, z_smooth_len)
float ema_aud = ta.ema(d_aud.z, z_smooth_len)
float ema_btc = ta.ema(d_btc.z, z_smooth_len)
float ema_jp225 = ta.ema(d_jp225.z, z_smooth_len)
float ema_nas = ta.ema(d_nas.z, z_smooth_len)
float ema_spx = ta.ema(d_us500.z, z_smooth_len)
float ema_dax = ta.ema(d_dax.z, z_smooth_len)
float ema_us02y = ta.ema(d_us02y.z, z_smooth_len)
float ema_oil = ta.ema(d_oil.z, z_smooth_len)
float ema_ej = ta.ema(d_ej.z, z_smooth_len)
float ema_gj = ta.ema(d_gj.z, z_smooth_len)
float ema_aj = ta.ema(d_aj.z, z_smooth_len)


type TradePair
    string name
    float score


var candidates = array.new<TradePair>(0)
var list_long = array.new<TradePair>(0)
var list_short = array.new<TradePair>(0)


f_add(_arr, _nm, _sc, _en, _z_val, _price, _sma, _v_ratio, _fractal_mult, _kurt, _phase_sync) =>
    float final_sc = _sc
    string display_nm = _nm
    float kairitsu = ((_price - _sma) / _sma) * 100
    bool is_squeeze = _v_ratio < 0.8
    bool is_expand = _v_ratio > 1.5
    bool is_fat_tail = _kurt > 6.0 // ğŸŒŒ Quantum Trigger (Fat Tail)
   
    float vol_adjustment = 1.0
    if _v_ratio < 0.6
        vol_adjustment := 1.15
    else if _v_ratio < 0.8
        vol_adjustment := 1.08
    else if _v_ratio > 2.0
        vol_adjustment := 0.65
    else if _v_ratio > 1.5
        vol_adjustment := 0.82
    else if _v_ratio > 1.2
        vol_adjustment := 0.93
   
    float position_adjustment = 0.0
    if math.abs(kairitsu) > 10
        position_adjustment := -0.15
    else if math.abs(kairitsu) > 7
        position_adjustment := -0.09
    else if math.abs(kairitsu) > 5
        position_adjustment := -0.05
    else if math.abs(kairitsu) > 3
        position_adjustment := -0.02
    else if math.abs(kairitsu) < 1
        position_adjustment := 0.07
   
    float z_adjustment = 0.0
    if math.abs(_z_val) > 3.0
        z_adjustment := -0.12
    else if math.abs(_z_val) > 2.5
        z_adjustment := -0.06
    else if math.abs(_z_val) > 2.0
        z_adjustment := -0.03
    else if math.abs(_z_val) < 0.5
        z_adjustment := 0.04
   
    // ğŸš€ Infinity Update: Apply Fractal Multiplier to Final Score
    final_sc := ((_sc * vol_adjustment) + position_adjustment + z_adjustment) * _fractal_mult
   
    if math.abs(_z_val) >= 3.5 or is_expand
        display_nm := "âš ï¸" + _nm + " (" + str.tostring(kairitsu, "#.1") + "%)"
    else if _phase_sync // ğŸŒŠ Phase Sync Override
        display_nm := "ğŸŒŠ" + _nm
    else if is_fat_tail and (math.sign(_sc) == math.sign(_z_val))
        display_nm := "âš¡" + _nm // Quantum Entry Trigger
    else if (math.abs(_z_val) <= 1.2 and is_squeeze) or (math.abs(_sc) >= sc_threshold and is_squeeze)
        display_nm := "ğŸ’£" + _nm
    else if math.abs(_z_val) <= 1.5
        display_nm := "ğŸš€" + _nm
    else
        display_nm := "ğŸ“ˆ" + _nm
    if _en and math.abs(_sc) >= sc_threshold
        array.push(_arr, TradePair.new(display_nm, final_sc))


f_populate_candidates() =>
    f_add(candidates, "XAUUSD", sc_xauusd, en_xau, ema_gold, d_gold.val, d_gold.sma200, d_gold.vol_ratio, fractal_mult, d_gold.kurt, d_gold.phase_sync)
// (XAGUSD removed from candidates)
    f_add(candidates, "USDJPY", sc_usdjpy, en_uj, ema_uj, d_uj.val, d_uj.sma200, d_uj.vol_ratio, fractal_mult, d_uj.kurt, d_uj.phase_sync)
    f_add(candidates, "EURUSD", sc_eurusd, en_eu, ema_eur, d_eur.val, d_eur.sma200, d_eur.vol_ratio, fractal_mult, d_eur.kurt, d_eur.phase_sync)
    f_add(candidates, "GBPUSD", sc_gbpusd, en_gu, ema_gbp, d_gbp.val, d_gbp.sma200, d_gbp.vol_ratio, fractal_mult, d_gbp.kurt, d_gbp.phase_sync)
    f_add(candidates, "AUDUSD", sc_audusd, en_au, ema_aud, d_aud.val, d_aud.sma200, d_aud.vol_ratio, fractal_mult, d_aud.kurt, d_aud.phase_sync)
// (USDCHF, USDCAD removed from candidates)
    f_add(candidates, "BTCUSD", sc_btc, en_btc, ema_btc, d_btc.val, d_btc.sma200, d_btc.vol_ratio, fractal_mult, d_btc.kurt, d_btc.phase_sync)
    f_add(candidates, "JP225", sc_jp225, en_jpn, ema_jp225, d_jp225.val, d_jp225.sma200, d_jp225.vol_ratio, fractal_mult, d_jp225.kurt, d_jp225.phase_sync)
    f_add(candidates, "NAS100", sc_nas, en_nas, ema_nas, d_nas.val, d_nas.sma200, d_nas.vol_ratio, fractal_mult, d_nas.kurt, d_nas.phase_sync)
    f_add(candidates, "US500", sc_spx, en_spx, ema_spx, d_us500.val, d_us500.sma200, d_us500.vol_ratio, fractal_mult, d_us500.kurt, d_us500.phase_sync)
    f_add(candidates, "GER40", sc_dax, en_dax, ema_dax, d_dax.val, d_dax.sma200, d_dax.vol_ratio, fractal_mult, d_dax.kurt, d_dax.phase_sync)
    f_add(candidates, "US02Y", sc_us02y, en_us02y, ema_us02y, d_us02y.val, d_us02y.sma200, d_us02y.vol_ratio, fractal_mult, d_us02y.kurt, d_us02y.phase_sync)
    f_add(candidates, "USOIL", sc_oil, en_oil, ema_oil, d_oil.val, d_oil.sma200, d_oil.vol_ratio, fractal_mult, d_oil.kurt, d_oil.phase_sync)
// âœ‚ï¸ ã‚¯ãƒ­ã‚¹å††ã®è¿½åŠ éƒ¨åˆ†ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å¤‰æ›´
    // åˆæˆä¾¡æ ¼(val_ej)ã‚’ä½¿ç”¨ã—ã€ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã¯ä¸­ç«‹(0ã‚„1.0)ã‚’æ¸¡ã—ã¦ã‚¹ã‚­ãƒƒãƒ—ã•ã›ã‚‹
    f_add(candidates, "EURJPY", sc_eurjpy, en_ej, 0, val_ej, val_ej, 1.0, fractal_mult, d_ej.kurt, false)
    f_add(candidates, "GBPJPY", sc_gbpjpy, en_gj, 0, val_gj, val_gj, 1.0, fractal_mult, d_gj.kurt, false)
    f_add(candidates, "AUDJPY", sc_audjpy, en_aj, 0, val_aj, val_aj, 1.0, fractal_mult, d_aj.kurt, false)


f_split_candidates() =>
    if array.size(candidates) > 0
        for i = 0 to array.size(candidates) - 1
            TradePair p = array.get(candidates, i)
            if p.score > 0
                array.push(list_long, p)
            else
                array.push(list_short, p)


// ==========================================
// (Orphaned block removed)


f_sort_lists() =>
    if array.size(list_long) > 1
        for i = 0 to array.size(list_long) - 2
            int max_idx = i
            for j = i + 1 to array.size(list_long) - 1
                if array.get(list_long, j).score > array.get(list_long, max_idx).score
                    max_idx := j
            if max_idx != i
                TradePair temp = array.get(list_long, i)
                array.set(list_long, i, array.get(list_long, max_idx))
                array.set(list_long, max_idx, temp)
   
    if array.size(list_short) > 1
        for i = 0 to array.size(list_short) - 2
            int min_idx = i
            for j = i + 1 to array.size(list_short) - 1
                if array.get(list_short, j).score < array.get(list_short, min_idx).score
                    min_idx := j
            if min_idx != i
                TradePair temp = array.get(list_short, i)
                array.set(list_short, i, array.get(list_short, min_idx))
                array.set(list_short, min_idx, temp)


// ğŸš€ MAIN EXECUTION (Stabilized)
// Calculate only on confirmed bars (Close) to prevent flickering
if barstate.isconfirmed
    array.clear(candidates)
    array.clear(list_long)
    array.clear(list_short)
    f_populate_candidates()
    f_split_candidates()
    f_sort_lists()


string top_long_name = array.size(list_long) > 0 ? array.get(list_long, 0).name : f_lang("Wait", "Neutral", "æ§˜å­è¦‹")
float top_long_score = array.size(list_long) > 0 ? array.get(list_long, 0).score : 0.0
string top_short_name = array.size(list_short) > 0 ? array.get(list_short, 0).name : f_lang("Wait", "Neutral", "æ§˜å­è¦‹")
float top_short_score = array.size(list_short) > 0 ? array.get(list_short, 0).score : 0.0


// ğŸŸ¢ ã€ä¿®æ­£2ã€‘ ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³å…¨ä½“ã‚’ä»¥ä¸‹ã§ä¸Šæ›¸ã
// ==========================================
// ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ & ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆ
// ==========================================
// (å¤‰æ•°ã¯ä¿®æ­£1ã§å®šç¾©æ¸ˆã¿ã®ãŸã‚ã€ã“ã“ã§ã¯ãƒ­ã‚¸ãƒƒã‚¯ã®ã¿è¨˜è¿°)


// ãƒ¬ã‚¸ãƒ¼ãƒ åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
// (stagflation legacy assignment removed)
bool policy_mistake = y_up and rising_unemp
bool strong_usd = d_up and y_up and s_up
bool fiat_debase = d_dn and g_up and d_eur.z < 0.2
bool yield_inv = d_us10y.val < d_us02y.val
bool good_yield_rise = corr_spx_yield > 0.3 and y_up and s_up
bool bad_yield_rise = corr_spx_yield < -0.3 and y_up and s_dn


float score = 0.0
score := score + (d_us500.z > 0.2 ? 1 : d_us500.z < -0.2 ? -1 : 0)
score := score + (d_nas.z > 0.2 ? 1 : d_nas.z < -0.2 ? -1 : 0)
score := score + (d_us500.is_bull ? 1 : -1)
score := score + (d_nas.is_bull ? 1 : -1)
if d_vix.val < 15
    score := score + 1.0
else if d_vix.val > 25
    score := score - 1.5
if d_vix.z < -0.5
    score := score + 0.5
else if d_vix.z > 0.5
    score := score - 1.0
bool risk_seeking = d_nas.chg > d_us500.chg
score := score + (risk_seeking ? 0.5 : -0.5)
score := score + (d_btc.z > 0.5 ? 0.5 : d_btc.z < -0.5 ? -0.5 : 0)
if d_us10y.z > 1.5
    score := score - 1.0
else if d_us10y.z < -1.0
    score := score + 0.5
if falling_conf
    score := score - 1.0


int star_count = 0
string star_icon = ""
string risk_mode_text = ""
color risk_color = color.gray
if score >= 4.0
    star_count := 5, risk_mode_text := "RISK ON", risk_color := #00e676, star_icon := "â˜…â˜…â˜…â˜…â˜…"
else if score >= 2.5
    star_count := 4, risk_mode_text := "RISK ON", risk_color := #66ffa6, star_icon := "â˜…â˜…â˜…â˜…â˜†"
else if score >= 1.0
    star_count := 3, risk_mode_text := "MILD ON", risk_color := #b9f6ca, star_icon := "â˜…â˜…â˜…â˜†â˜†"
else if score > -1.0
    star_count := 2, risk_mode_text := "NEUTRAL", risk_color := color.gray, star_icon := "â˜…â˜…â˜†â˜†â˜†"
else if score > -3.0
    star_count := 3, risk_mode_text := "RISK OFF", risk_color := #ff8a80, star_icon := "â˜…â˜…â˜…â˜†â˜†"
else if score > -5.0
    star_count := 4, risk_mode_text := "RISK OFF", risk_color := #ff5252, star_icon := "â˜…â˜…â˜…â˜…â˜†"
else
    star_count := 5, risk_mode_text := "CRASH", risk_color := #ff1744, star_icon := "â˜…â˜…â˜…â˜…â˜…"


string msg_main = f_lang("Range", "Rango", "ãƒ¬ãƒ³ã‚¸")
string msg_ctx = f_lang("No drivers. Random walk.", "Sin drivers. Movimiento aleatorio.", "ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ä¸åœ¨ã€‚å€‹åˆ¥è¦å› ã§å‹•ãã€‚")
color c_bg = color.new(color.gray, 20)


// ğŸ”— Map Legacy Variables to New Engine
bool liquidity_crisis = reg_liq_crisis
bool stagflation = reg_stagflation
bool reflation_trade = reg_reflation
bool deflation_risk = reg_deflation
bool goldilocks = reg_goldilocks


bool tech_rotation = d_nas.z < -1.0 and d_us500.z > 0.5
bool value_rotation = d_nas.z > -0.5 and d_us500.z > 1.0 and d_nas.chg < d_us500.chg
bool commodity_boom = d_oil.z > 1.5 and d_gold.z > 1.0
bool dollar_dominance = d_dxy.z > 1.5 and d_eur.z < -1.0 and d_gbp.z < -1.0
bool em_stress = d_aud.z < -1.0 and d_oil.z < -0.5
bool safe_haven_flow = d_vix.z > 1.0 and d_gold.z > 1.0 and d_us10y.z < 0
bool rate_cut_speculation = d_us10y.z < -1.5 and d_us500.z > 1.0


// ==========================================
// ==========================================
// ğŸ§  Context Logic Engine (Function for memory optimization)
// ==========================================
type MarketCtx
    string main
    string sub
    color bg


// ğŸŸ¢ ã€ä¿®æ­£3ã€‘ ã“ã®é–¢æ•°å…¨ä½“ã‚’ä»¥ä¸‹ã§ä¸Šæ›¸ã
// ğŸš€ Optimized to use implicit local scope (accessing globals defined above)
f_get_market_ctx() =>
    string _m = f_lang("Range", "Rango", "ãƒ¬ãƒ³ã‚¸")
    // ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«2ã§å®šç¾©ã—ãŸ cycle_msg ã‚’å¾©æ´»
    string _driver = w_liq > 0.6 ? "Liq Driven" : "Rate Driven"
    string _s_en = cycle_msg + " | " + _driver
    string _s_jp = (is_hiking_cycle ? "åˆ©ä¸Šå±€é¢" : is_cutting_cycle ? "åˆ©ä¸‹å±€é¢" : "ä¸­ç«‹") + " | " + (w_liq > 0.6 ? "æµå‹•æ€§ç›¸å ´" : "é‡‘åˆ©ç›¸å ´")
    string _s = f_lang(_s_en, _s_en, _s_jp)
    color _c = color.new(color.gray, 20)
   
    // Priority 1: Extreme Risks
    if panic_mode
        _m := f_lang("PANIC MODE", "MODO PÃNICO", "ãƒ‘ãƒ‹ãƒƒã‚¯ç›¸å ´")
        _s := f_lang("VIX Spike. Cash is king.", "Pico VIX. Efectivo es rey.", "VIXæ€¥é¨°ã€‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºä¿ã€‚")
        _c := color.new(color.navy, 10)
    else if liquidity_crisis
        _m := f_lang("Liquidity Crisis", "Crisis Liquidez", "æµå‹•æ€§å±æ©Ÿ")
        _s := f_lang("Net Liq Draining.", "Drenaje Liquidez.", "æµå‹•æ€§æ€¥æ¸›ã€‚")
        _c := color.new(#8b0000, 10)
    else if jpy_crash
        _m := f_lang("Yen Crash", "Colapso Yen", "å††å®‰ã‚¯ãƒ©ã‚¤ãƒãƒƒã‚¯ã‚¹")
        _s := f_lang("Intervention alert.", "Alerta IntervenciÃ³n.", "ä»‹å…¥è­¦æˆ’ã€‚")
        _c := color.new(#880e4f, 10)
    // Priority 2: Major Regimes
    else if goldilocks
        _m := f_lang("GOLDILOCKS", "Ricitos de Oro", "ã‚´ãƒ«ãƒ‡ã‚£ãƒ­ãƒƒã‚¯ã‚¹")
        _s := f_lang("Growthâ†‘ Yieldsâ†’", "Crecimientoâ†‘ Tasasâ†’", "é©æ¸©ç›¸å ´ã€‚æ ªé«˜ã€‚")
        _c := color.new(#00c853, 10)
    else if stagflation
        _m := f_lang("Stagflation", "EstanflaciÃ³n", "ã‚¹ã‚¿ã‚°ãƒ•ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³")
        _s := f_lang("Infâ†‘ Growthâ†“", "Infâ†‘ Crecimientoâ†“", "ä¸æ³ä¸‹ã®ç‰©ä¾¡é«˜ã€‚")
        _c := color.new(#b71c1c, 10)
    else if reflation_trade
        _m := f_lang("Reflation", "ReflaciÃ³n", "ãƒªãƒ•ãƒ¬ãƒˆãƒ¬ãƒ¼ãƒ‰")
        _s := f_lang("Oilâ†‘ Yieldsâ†‘ Stocksâ†‘", "PetrÃ³leoâ†‘ Tasasâ†‘", "åŸæ²¹ãƒ»é‡‘åˆ©ãƒ»æ ªé«˜ã€‚")
        _c := color.new(#1b5e20, 10)
    else if deflation_risk
        _m := f_lang("Deflation Risk", "Riesgo DeflaciÃ³n", "ãƒ‡ãƒ•ãƒ¬æ‡¸å¿µ")
        _s := f_lang("All Dropping.", "Todo cayendo.", "å…¨é¢å®‰ãƒ»é‡‘åˆ©ä½ä¸‹ã€‚")
        _c := color.new(#37474f, 10)
    // Priority 3: Market Themes
    else if policy_mistake
        _m := "Policy Mistake", _c := color.new(#4a148c, 10)
    else if dollar_dominance
        _m := "USD Dominance", _c := color.new(#1b5e20, 10)
    else if commodity_boom
        _m := "Commodity Boom", _c := color.new(#e65100, 10)
    else if tech_rotation
        _m := "Tech Rotation", _c := color.new(#4a148c, 10)
    else if value_rotation
        _m := "Value Lead", _c := color.new(#33691e, 10)
    else if safe_haven_flow
        _m := "Safe Haven", _c := color.new(#263238, 10)
    else if rate_cut_speculation
        _m := "Rate Cut Bets", _c := color.new(#004d40, 10)
    else if em_stress
        _m := "EM Stress", _c := color.new(#bf360c, 10)
    else if d_up and s_dn
        _m := "USD Haven", _c := color.new(#311b92, 10)
    else if j_up and s_dn
        _m := "Risk-Off (Yen)", _c := color.new(#1a237e, 10)
    else if j_up and d_dn
        _m := "Heavy (Yenâ†‘ USDâ†“)", _c := color.new(color.gray, 20)
    else if d_up and j_dn
        _m := "USD Bid", _c := color.new(#0d47a1, 10)
    else if bad_yield_rise
        _m := "Bad Yield Rise", _c := color.new(#4a148c, 10)
    else if score >= 3.0
        _m := risk_seeking ? "Goldilocks" : "Defensive"
        _s := risk_seeking ? "Risk On" : "Defensive Rotation"
        _c := risk_seeking ? color.new(#00c853, 10) : color.new(#2e7d32, 10)
    else if score <= -3.0
        _m := "Bear Trend"
        _s := "Downtrend"
        _c := color.new(#3e2723, 10)
    else
        if s_up
            _m := "Firm", _s := "Uptrend", _c := color.new(color.green, 20)
        else if s_dn
            _m := "Soft", _s := "Heavy", _c := color.new(color.gray, 20)


    MarketCtx.new(_m, _s, _c)


// ğŸš€ Call Optimized Function
MarketCtx ctx_data = f_get_market_ctx()
msg_main := ctx_data.main
msg_ctx := ctx_data.sub
c_bg := ctx_data.bg


if is_weekend and syminfo.type != "crypto"
    msg_ctx := msg_ctx + f_lang("\nâš ï¸ Weekend: Data frozen", "\nâš ï¸ Fin de semana: Datos congelados", "\nâš ï¸ é€±æœ«: ãƒ‡ãƒ¼ã‚¿åœæ­¢ä¸­")


// ==========================================
// ğŸ¨ UI: Ultimate Cockpit Design (Ver 4.0)
// ==========================================


// --- Premium Palette ---
color c_vip_bg   = color.new(#000000, 20) // Deep Black Glass
color c_neon_g   = #00e676 // Matrix Green
color c_neon_r   = #ff1744 // Cyber Red
color c_neon_b   = #2979ff // Electric Blue
color c_gold     = #ffd700 // Premium Gold
color c_text_w   = #eceff1 // Platinum White
color c_text_g   = #b0bec5 // Titanium Gray


// --- Visual Helpers ---
f_bar(_val, _max, _is_bi) =>
    float _norm = math.min(math.abs(_val), _max)
    // Scale: 0.5 score = 1 bar (Max 5.0 -> 10 bars)
    int _bars = math.round(_norm * 2.0)
    string _s = ""
    string _icon = "/" // User requested slash
    if _bars > 0
        for i = 1 to _bars
            _s := _s + _icon
    // No brackets, pure bars
    _s


f_meter(_val) =>
    _val > 0.8 ? "âš¡âš¡âš¡" : _val > 0.5 ? "âš¡âš¡" : "âš¡"


// --- Dashboard Logic ---


// ãƒªã‚¹ãƒˆç”Ÿæˆï¼ˆLongï¼‰- Card Style
string txt_long = ""
if array.size(list_long) > 0
    int max_display = math.min(array.size(list_long), max_pairs)
    for i = 0 to max_display - 1
        TradePair p = array.get(list_long, i)
        string _b = f_bar(p.score, 5.0, false)
        // Clean Text: Removed "ğŸš€"
        txt_long := txt_long + p.name + " " + _b + "\n"
else
    txt_long := "Wait..."


// ãƒªã‚¹ãƒˆç”Ÿæˆï¼ˆShortï¼‰- Card Style
string txt_short = ""
if array.size(list_short) > 0
    int max_display_short = math.min(array.size(list_short), max_pairs)
    for i = 0 to max_display_short - 1
        TradePair p = array.get(list_short, i)
        string _b = f_bar(p.score, 5.0, false)
        // Clean Text: Removed "ğŸ’€"
        txt_short := txt_short + p.name + " " + _b + "\n"
else
    txt_short := "Cash..."


// ãƒ†ãƒ¼ãƒ–ãƒ«ä½ç½®è¨­å®š (Directly use processed input)
// The pos_input Logic at top of file (lines 71-89) already converts User String -> Pine Constant.
// So we just use pos_input directly.

// ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ (3 Rows for Compact Vertical Layout)
// Row 0: Header
// Row 1: Status (L) | Long (R)
// Row 2: Driver (L) | Short (R)
// Row 3: Spacer (Transparent)
var table panel = table.new(pos_input, 2, 8, border_width=0, border_color=color.new(color.gray, 100))


// ==========================================
// ğŸ¨ UI: New Layout (Split: Left Status / Right Signals)
// ==========================================

// ğŸŸ¢ Status Text Generator (Comprehensive Natural Language)
f_get_status_text() =>
    string _txt = ""
    
    // 1. Global Liquidity (Liq)
    string l_title = lang_select == "æ—¥æœ¬èª" ? "ãƒ»æµå‹•æ€§: " : (lang_select == "EspaÃ±ol" ? "ãƒ»Liq: " : "ãƒ»Liq: ")
    string l_val = ""
    if Global_Liq_Score > 1.0
        l_val := lang_select == "æ—¥æœ¬èª" ? "æ¥µã‚ã¦æ½¤æ²¢" : (lang_select == "EspaÃ±ol" ? "Extrema" : "Abundant")
    else if Global_Liq_Score > 0.0
        l_val := lang_select == "æ—¥æœ¬èª" ? "å®‰å®šæ¨ç§»" : (lang_select == "EspaÃ±ol" ? "Estable" : "Stable")
    else if Global_Liq_Score > -1.0
        l_val := lang_select == "æ—¥æœ¬èª" ? "ã‚„ã‚„é€¼è¿«" : (lang_select == "EspaÃ±ol" ? "Ajustada" : "Tightening")
    else
        l_val := lang_select == "æ—¥æœ¬èª" ? "æ¯æ¸‡æ°—å‘³ (æ³¨æ„)" : (lang_select == "EspaÃ±ol" ? "Agotada (Aviso)" : "Depleted (Warn)")
    _txt := _txt + l_title + l_val + "\n"
    
    // 2. Volatility (VIX)
    string v_title = lang_select == "æ—¥æœ¬èª" ? "ãƒ»ãƒœãƒ©: " : (lang_select == "EspaÃ±ol" ? "ãƒ»Vol: " : "ãƒ»Vol: ")
    string v_val = ""
    if panic_mode
        v_val := lang_select == "æ—¥æœ¬èª" ? "ãƒ‘ãƒ‹ãƒƒã‚¯ (è­¦æˆ’)" : (lang_select == "EspaÃ±ol" ? "PÃ¡nico (Alerta)" : "Panic (Alert)")
    else if d_vix.val < 15
        v_val := lang_select == "æ—¥æœ¬èª" ? "é™ç© (ãƒªã‚¹ã‚¯é¸å¥½)" : (lang_select == "EspaÃ±ol" ? "Calma (Risk-On)" : "Calm (Risk-On)")
    else if d_vix.val > 20
        v_val := lang_select == "æ—¥æœ¬èª" ? "æ‹¡å¤§ä¸­ (ä¸å®‰å®š)" : (lang_select == "EspaÃ±ol" ? "Alta (Inestable)" : "Expanding")
    else
        v_val := lang_select == "æ—¥æœ¬èª" ? "é€šå¸¸ãƒ¬ãƒ™ãƒ«" : (lang_select == "EspaÃ±ol" ? "Normal" : "Normal")
    _txt := _txt + v_title + v_val + "\n"

    // 3. Trend Quality (Hurst)
    string h_title = lang_select == "æ—¥æœ¬èª" ? "ãƒ»ãƒˆãƒ¬ãƒ³ãƒ‰: " : (lang_select == "EspaÃ±ol" ? "ãƒ»Tend: " : "ãƒ»Trend: ")
    string h_val = ""
    if h_high
        h_val := lang_select == "æ—¥æœ¬èª" ? "æ˜ç¢ºãªç™ºç”Ÿä¸­" : (lang_select == "EspaÃ±ol" ? "Fuerte" : "Strong")
    else if h_low
        h_val := lang_select == "æ—¥æœ¬èª" ? "æ–¹å‘æ„Ÿãªã— (ãƒ¬ãƒ³ã‚¸)" : (lang_select == "EspaÃ±ol" ? "Sin Rumbo" : "Aimless")
    else
        h_val := lang_select == "æ—¥æœ¬èª" ? "ä¸­ç«‹" : (lang_select == "EspaÃ±ol" ? "Neutral" : "Neutral")
    _txt := _txt + h_title + h_val + "\n"

    // 4. Market Physics (Velocity & Coherence)
    float vel_mag = math.abs(d_us500.velocity)
    string p_title = lang_select == "æ—¥æœ¬èª" ? "ãƒ»å‹¢ã„: " : (lang_select == "EspaÃ±ol" ? "ãƒ»Velo: " : "ãƒ»Velo: ")
    string p_val = ""
    if vel_mag > 0.8
        p_val := lang_select == "æ—¥æœ¬èª" ? "éå¸¸ã«å¼·ã„" : (lang_select == "EspaÃ±ol" ? "Muy Alta" : "Very High")
    else if vel_mag > 0.5
        p_val := lang_select == "æ—¥æœ¬èª" ? "å¼·ã„" : (lang_select == "EspaÃ±ol" ? "Alta" : "High")
    else
        p_val := lang_select == "æ—¥æœ¬èª" ? "å¼±ã„" : (lang_select == "EspaÃ±ol" ? "Baja" : "Low")
    _txt := _txt + p_title + p_val + "\n"

    string c_title = lang_select == "æ—¥æœ¬èª" ? "ãƒ»ç›¸é–¢: " : (lang_select == "EspaÃ±ol" ? "ãƒ»Corr: " : "ãƒ»Corr: ")
    string c_val = ""
    if is_sys_risk
        c_val := lang_select == "æ—¥æœ¬èª" ? "å…¨è³‡ç”£åŒèª¿ (å±é™º)" : (lang_select == "EspaÃ±ol" ? "SistÃ©mico (Riesgo)" : "Systemic (Risk)")
    else if is_coherent_trend
        c_val := lang_select == "æ—¥æœ¬èª" ? "å¥å…¨ãªé€£å‹•" : (lang_select == "EspaÃ±ol" ? "Coherente" : "Coherent")
    else
        c_val := lang_select == "æ—¥æœ¬èª" ? "å€‹åˆ¥è¦å›  (åˆ†æ•£)" : (lang_select == "EspaÃ±ol" ? "Divergente" : "Divergent")
    _txt := _txt + c_title + c_val + "\n"
    
    // 5. Structure (Reynolds)
    string r_title = lang_select == "æ—¥æœ¬èª" ? "ãƒ»æ§‹é€ : " : (lang_select == "EspaÃ±ol" ? "ãƒ»Est: " : "ãƒ»Struct: ")
    string r_val = ""
    if is_turbulent
        r_val := lang_select == "æ—¥æœ¬èª" ? "ä¹±æµ (ä¸å®‰å®š)" : (lang_select == "EspaÃ±ol" ? "Turbulento" : "Turbulent")
    else
        r_val := lang_select == "æ—¥æœ¬èª" ? "æ•´æµ (å®‰å®š)" : (lang_select == "EspaÃ±ol" ? "Laminar" : "Laminar")
    
    _txt := _txt + r_title + r_val
    _txt

string status_desc = f_get_status_text()

// ğŸŸ¢ Driver Bar Logic (Sorting top drivers)
type Driver
    string name
    float val
    float abs_val

f_get_drivers_txt() =>
    // Create list of drivers
    var d_list = array.new<Driver>(0)
    array.clear(d_list)
    array.push(d_list, Driver.new("US02Y", d_us02y.z, math.abs(d_us02y.z)))
    array.push(d_list, Driver.new("VIX", d_vix.z, math.abs(d_vix.z)))
    array.push(d_list, Driver.new("SPX", d_us500.z, math.abs(d_us500.z)))
    array.push(d_list, Driver.new("DXY", d_dxy.z, math.abs(d_dxy.z)))
    array.push(d_list, Driver.new("US10Y", d_us10y.z, math.abs(d_us10y.z)))
    array.push(d_list, Driver.new("GOLD", d_gold.z, math.abs(d_gold.z)))

    // Sort by absolute Z-score (Impact)
    int n = array.size(d_list)
    if n > 1
        for i = 0 to n - 2
            int max_idx = i
            for j = i + 1 to n - 1
                if array.get(d_list, j).abs_val > array.get(d_list, max_idx).abs_val
                    max_idx := j
            if max_idx != i
                Driver temp = array.get(d_list, i)
                array.set(d_list, i, array.get(d_list, max_idx))
                array.set(d_list, max_idx, temp)
    
    // Format Top 4
    string _res = ""
    for i = 0 to math.min(n, 4) - 1
        Driver d = array.get(d_list, i)
        string _arrow = d.val > 0.2 ? "â¬†" : (d.val < -0.2 ? "â¬‡" : "â”")
        _res := _res + d.name + " " + _arrow + "   "
    _res

string driver_txt = f_get_drivers_txt()

// ğŸŸ¢ æç”»å‡¦ç† using NEW Logic
if barstate.islast
    // Color Logic (Same as before)
    color c_status_bg = c_vip_bg
    if panic_mode or liquidity_crisis
        c_status_bg := color.new(c_neon_r, 40)
    else if score >= 3.0
        c_status_bg := color.new(c_neon_g, 40)
    else if score >= 1.0
        c_status_bg := color.new(c_neon_g, 70)
    else if score <= -3.0
        c_status_bg := color.new(c_neon_r, 40)
    else if score <= -1.0
        c_status_bg := color.new(c_neon_r, 70)

    // Dark Header Color
    color c_header_bg = color.new(#333333, 10)

    // --- Row 0: Header Row (Unified & Centered) ---
    // Header Text
    string header_title = "TRUE NORTH [" + sel_mode + "]"
    
    // Vertical Signal Lists (Dynamic Height)
    string txt_l_vert = ""
    int n_l = array.size(list_long)
    int show_l = math.min(n_l, 5)
    
    if n_l > 0
        for i = 0 to show_l - 1
            TradePair p = array.get(list_long, i)
            string _b = f_bar(p.score, 5.0, false)
            string _line = p.name + " " + _b
            txt_l_vert := txt_l_vert + _line + (i < show_l - 1 ? "\n" : "")
    else
        txt_l_vert := f_lang("Wait...", "Espera...", "æ§˜å­è¦‹...")
        
    // Short List (Dynamic Height)
    string txt_s_vert = ""
    int n_s = array.size(list_short)
    int show_s = math.min(n_s, 5)
    
    if n_s > 0
        for i = 0 to show_s - 1
            TradePair p = array.get(list_short, i)
            string _b = f_bar(p.score, 5.0, false)
            string _line = p.name + " " + _b
            txt_s_vert := txt_s_vert + _line + (i < show_s - 1 ? "\n" : "")
    else
        txt_s_vert := f_lang("Cash...", "Efectivo", "ã‚­ãƒ£ãƒƒã‚·ãƒ¥")
    
    // Define variables needed for both compact and full cockpit modes, or for the full cockpit mode outside its block
    // FRB 3-Month Delta Logic (Calculation moved to global scope)
    float spread_new = val_ref_new - val_ref_3m
    string cyc_arrow_new = spread_new > 0.1 ? "â‡¡" : (spread_new < -0.1 ? "â‡£" : "â†’")
    string frb_txt = "FRB: " + str.tostring(val_ref_new, "#.##") + "% " + cyc_arrow_new
    
    string sys_go_jp = score >= 3.0 ? "ğŸš€ å…¨ã‚·ã‚¹ãƒ†ãƒ ç¨¼åƒ" : score <= -3.0 ? "ğŸ» å®Œå…¨é˜²è¡›ãƒ¢ãƒ¼ãƒ‰" : "â³ å¾…æ©Ÿ (ãƒ¬ãƒ³ã‚¸)"
    string sys_go_es = score >= 3.0 ? "ğŸš€ SISTEMAS GO" : score <= -3.0 ? "ğŸ» DEFENSA TOTAL" : "â³ ESPERA"
    string sys_go_en = score >= 3.0 ? "ğŸš€ ALL SYSTEMS GO" : score <= -3.0 ? "ğŸ» TOTAL DEFENSE" : "â³ HOLDING PATTERN"
    string sys_go_final = veto_fast ? (lang_select == "æ—¥æœ¬èª" ? "ğŸš« æ‹’å¦ (VETO)" : (lang_select == "EspaÃ±ol" ? "ğŸš« VETO" : "ğŸš« VETO")) : (lang_select == "æ—¥æœ¬èª" ? sys_go_jp : (lang_select == "EspaÃ±ol" ? sys_go_es : sys_go_en))

    // Unified Right Column Text Blocks (Title included for compact rows)
    string right_long_block = "LONG\n" + txt_l_vert
    string right_short_block = "SHORT\n" + txt_s_vert

    // Dynamic Size Logic (using table_scale input)
    // table_scale 1-7. Default 4.
    // We map 4 -> Size.Normal / Size.Small
    string sz_norm_dyn = size.normal
    string sz_small_dyn = size.small
    
    if table_scale == 1
        sz_norm_dyn := size.small
        sz_small_dyn := size.tiny
    else if table_scale == 2
        sz_norm_dyn := size.small
        sz_small_dyn := size.tiny
    else if table_scale == 3
        sz_norm_dyn := size.normal
        sz_small_dyn := size.small
    else if table_scale == 4 // Default
        sz_norm_dyn := size.normal
        sz_small_dyn := size.small // Keep small for secondary text if needed, but User asked for Normal for Tickers
    else if table_scale == 5
        sz_norm_dyn := size.large
        sz_small_dyn := size.normal
    else if table_scale == 6
        sz_norm_dyn := size.large
        sz_small_dyn := size.normal
    else if table_scale == 7
        sz_norm_dyn := size.huge
        sz_small_dyn := size.large
        
    // User requested Tickers be same size as FRB (Normal).
    // So we use sz_norm_dyn for almost everything.

    if show_signals_only
        // --- 1 Column Mode (Compact) ---
        table.cell(panel, 0, 0, header_title, bgcolor=c_header_bg, text_color=c_text_w, text_size=sz_norm_dyn, text_halign=text.align_center)
        
        table.cell(panel, 0, 1, "LONG", bgcolor=c_vip_bg, text_color=c_text_w, text_size=sz_small_dyn, text_halign=text.align_left)
        table.cell(panel, 0, 2, txt_l_vert, bgcolor=c_vip_bg, text_color=c_neon_g, text_size=sz_norm_dyn, text_halign=text.align_left)
        table.cell(panel, 0, 3, "SHORT", bgcolor=c_vip_bg, text_color=c_text_w, text_size=sz_small_dyn, text_halign=text.align_left)
        table.cell(panel, 0, 4, txt_s_vert, bgcolor=c_vip_bg, text_color=c_neon_r, text_size=sz_norm_dyn, text_halign=text.align_left)
        
        // Clean up Right Column
        table.merge_cells(panel, 1, 0, 1, 6)
        table.cell(panel, 1, 0, "", bgcolor=color.new(color.black, 100))
        
    else
        // --- 2 Column Mode (Full Cockpit) ---
        // Layout: Driver Up (Row 2) + Independent Left Status
        
        // Row 0: Header (Spans 2 columns)
        table.cell(panel, 0, 0, header_title, bgcolor=c_header_bg, text_color=c_text_w, text_size=sz_norm_dyn, text_halign=text.align_center)
        table.merge_cells(panel, 0, 0, 1, 0)
        
        // Full Left Block Content (Sys + FRB + Status + Driver)
        // User Request: 
        // 1. FRB to right of Sys (Top Line).
        // 2. Driver in FRB's old spot (Bottom).
        string driver_compact = f_get_drivers_txt()
        string full_left_block = sys_go_final + "   " + frb_txt + "\n" + status_desc + "\n" + driver_compact
        
        // Row 1: Left Status (Merged R1-R2) | Right Long Block
        // We merge Left R1-R2 to create a single pane for the stacked info.
        table.merge_cells(panel, 0, 1, 0, 2)
        table.cell(panel, 0, 1, full_left_block, bgcolor=c_status_bg, text_color=c_text_w, text_size=sz_norm_dyn, text_halign=text.align_left, text_valign=text.align_top)
        
        table.cell(panel, 1, 1, right_long_block, bgcolor=c_vip_bg, text_color=c_neon_g, text_size=sz_norm_dyn, text_halign=text.align_left, text_valign=text.align_top)
        
        // Row 2: Right Short Block (Align Top)
        // Left is merged, so we only set Right.
        table.cell(panel, 1, 2, right_short_block, bgcolor=c_vip_bg, text_color=c_neon_r, text_size=sz_norm_dyn, text_halign=text.align_left, text_valign=text.align_top)
        
        // Row 3: Transparent Spacer (Left & Right)
        table.cell(panel, 0, 3, "", bgcolor=color.new(color.black, 100), text_size=size.tiny)
        table.cell(panel, 1, 3, "", bgcolor=color.new(color.black, 100), text_size=size.tiny)
        
        // Unmerge Left R1-R2 (Previously merged in Step 836)
        // In this logic, we call table.cell directly for Row 1 and Row 2.
        // No merge calls needed for R1-R2.
        // This ensures Driver (R2) is independent and has Gray BG.
        
        // Alignment Check:
        // Left R1 (Status) aligns BOTTOM.
        // Right R1 (Long) aligns TOP.
        // If Right R1 is taller than Left R1, empty space appears ABOVE Status.
        // Status sits directly on top of Row 2 (Driver).
        // This creates "Struct -> FRB -> [Border] -> Driver".
        // Driver is Row 2.
        // Right R2 (Short) starts at same level as Driver.
        // If Short is taller than Driver, Driver sits centered/top in Row 2.
        // Spacer (R3) follows.


// ==========================================
// ==========================================
// ğŸ”” DYNAMIC NOTIFICATION SYSTEM (God-Tier)
// ==========================================

// Helper: Format Dynamic Message
f_notify(_title, _msg, _ticker, _act, _sc, _u_txt) =>
    string _t = str.format("{0,time,short}", timenow) // Safe Time Format
    string _p = str.tostring(close, "#.####") // Safe Price Format
    string _chg = str.tostring((close - close[1])/close[1]*100, "#.##") + "%"
    
    // JSON-like Structure for Webhooks (Optional) or Clean Text
    // "[Time] [Mode] TICKER | ACTION | Score: X.X | Context | Price"
    string _base = "ğŸš€ [" + sel_mode + "] " + _ticker + " " + _act + "\n"
    string _det = "ğŸ“Š Score: " + str.tostring(_sc, "#.1") + " | " + _u_txt + "\n"
    string _mkt = "ï¿½ Price: " + _p + " (" + _chg + ") | " + _msg
    _title + "\n" + _base + _det + _mkt

// Triggers (Confirmed Only)
bool is_conf = barstate.isconfirmed

// 1. Regime Shift
bool chg_regime = risk_mode_text != risk_mode_text[1] and is_conf
alertcondition(chg_regime, "ğŸ”” Regime Shift", "Market regime changed")

// 2. Rating Up
bool chg_stars_up = star_count > star_count[1] and is_conf
alertcondition(chg_stars_up, "ğŸŒŸ Rating Up", "Score improved")

// 3. Panic Mode
alertcondition(panic_mode and is_conf, "ğŸš¨ Panic", "VIX exceeded warning level")

// 4. Z-Score Extreme
bool z_extreme = ((math.abs(d_gold.z) > 2.0 and math.abs(d_gold.z) > math.abs(d_gold.z[1])) or (math.abs(d_us10y.z) > 2.0 and math.abs(d_us10y.z) > math.abs(d_us10y.z[1]))) and is_conf
alertcondition(z_extreme, "âš¡ Z-Score Extreme", "Gold/Yields at Â±2Ïƒ")

// 5. SMA Cross
bool sma_cross = (ta.crossover(d_us500.val, d_us500.sma200) or ta.crossunder(d_us500.val, d_us500.sma200)) and is_conf
alertcondition(sma_cross, "ğŸ”„ SMA200 Cross", "S&P crossed long-term pivot")

// 6. Go Signal (Top Long Change or New Entry)
bool go_signal = (top_long_name != f_lang("Wait", "Neutral", "æ§˜å­è¦‹") and top_long_name[1] == f_lang("Wait", "Neutral", "æ§˜å­è¦‹")) and is_conf
alertcondition(go_signal, "ğŸš€ Go Signal", "Recommendation emerged")

// 7. Pair Change
bool pair_change = (top_long_name != top_long_name[1] and top_long_name != f_lang("Wait", "Neutral", "æ§˜å­è¦‹")) and is_conf
alertcondition(pair_change, "ğŸ’± Pair Changed", "Top pair switched")

// 8. High Confidence
bool high_score = (top_long_score > 2.5 and top_long_score[1] <= 2.5) and is_conf
alertcondition(high_score, "ğŸ¯ High Confidence", "Score exceeded 2.5")

// 9. Squeeze Alert (Whale Flow)
bool squeeze_alert = (d_gold.vol_ratio < 0.8 and d_gold.vol_ratio[1] >= 0.8) or (d_uj.vol_ratio < 0.8 and d_uj.vol_ratio[1] >= 0.8) or (d_nas.vol_ratio < 0.8 and d_nas.vol_ratio[1] >= 0.8) or (d_btc.vol_ratio < 0.8 and d_btc.vol_ratio[1] >= 0.8)
bool squeeze_fired = squeeze_alert and is_conf
alertcondition(squeeze_fired, "ï¿½ Energy Release", "Major asset squeeze detected")

// ----------------------------------------------------
// ğŸ“² DYNAMIC ALERT TRIGGER (One Alert to Rule Them All)
// ----------------------------------------------------
if is_conf
    string _alert_msg = ""
    
    // Priority 1: Panic/Crisis
    if panic_mode and not panic_mode[1]
        _alert_msg := f_notify("ğŸš¨ PANIC PROTOCOL", "VIX Spike > 30. Cash is King.", "ALL MARKETS", "DEFENSE", score, risk_mode_text)
        alert(_alert_msg, alert.freq_once_per_bar_close)
        
    // Priority 2: Go Signal / Rotation
    else if go_signal or pair_change
        string _tick = top_long_name
        float _sc = top_long_score
        string _act = "GO LONG"
        string _reason = "Top Rank Rotation"
        _alert_msg := f_notify("TRUE NORTH SIGNAL", _reason, _tick, _act, _sc, risk_mode_text)
        alert(_alert_msg, alert.freq_once_per_bar_close)
        
    // Priority 3: Squeeze
    else if squeeze_fired
        // Find who squeezed (Simplified)
        string _sq_tick = "ASSET"
        if d_gold.vol_ratio < 0.8
            _sq_tick := "GOLD"
        else if d_btc.vol_ratio < 0.8
            _sq_tick := "BTC"
        else if d_nas.vol_ratio < 0.8
            _sq_tick := "NAS100"
            
        _alert_msg := f_notify("ğŸ’£ SQUEEZE DETECTED", "Volatility compression breaking.", _sq_tick, "WATCH", 0.0, "Energy Loading")
        alert(_alert_msg, alert.freq_once_per_bar_close)

